<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Paratii Source: paratii.ipfs.local.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.simplex.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Paratii</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Paratii.html">Paratii</a></li><li><a href="ParatiiCore.html">ParatiiCore</a></li><li><a href="ParatiiCoreUsers.html">ParatiiCoreUsers</a></li><li><a href="ParatiiCoreVids.html">ParatiiCoreVids</a></li><li><a href="ParatiiDb.html">ParatiiDb</a></li><li><a href="ParatiiDbUsers.html">ParatiiDbUsers</a></li><li><a href="ParatiiDbVids.html">ParatiiDbVids</a></li><li><a href="ParatiiEth.html">ParatiiEth</a></li><li><a href="ParatiiEthEvents.html">ParatiiEthEvents</a></li><li><a href="ParatiiEthTcr.html">ParatiiEthTcr</a></li><li><a href="ParatiiEthUsers.html">ParatiiEthUsers</a></li><li><a href="ParatiiEthVids.html">ParatiiEthVids</a></li><li><a href="ParatiiEthVouchers.html">ParatiiEthVouchers</a></li><li><a href="ParatiiIPFS.html">ParatiiIPFS</a></li><li><a href="ParatiiIPFSLocal.html">ParatiiIPFSLocal</a></li><li><a href="ParatiiIPFSRemote.html">ParatiiIPFSRemote</a></li><li><a href="ParatiiTranscoder.html">ParatiiTranscoder</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html">Global</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: paratii.ipfs.local.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript ">/* global File, ArrayBuffer */
'use strict'

import { EventEmitter } from 'events'
// import Protocol from 'paratii-protocol'
const pull = require('pull-stream')
const pullFilereader = require('pull-filereader')
const toPull = require('stream-to-pull-stream')
const fs = require('fs')
const path = require('path')
const { eachSeries, nextTick } = require('async')
const once = require('once')
// const Multiaddr = require('multiaddr')
// const Resumable = require('resumablejs')

/**
 * IPFS UPLOADER : Paratii IPFS uploader interface.
 * @extends EventEmitter
 * @param {ParatiiIPFSUploaderSchema} opts
 */
export class ParatiiIPFSLocal extends EventEmitter {
  /**
  * @typedef {Array} ParatiiIPFSUploaderSchema
  * @property {?ipfsSchema} ipfs
  * @property {?Object} ParatiiIPFS
  */
  constructor (config) {
    super()
    // const schema = joi.object({
    //   ipfs: ipfsSchema,
    //   paratiiIPFS: joi.object().optional()
    // //   onReadyHook: joi.array().ordered().default([]),
    // //   protocol: joi.string().default(null),
    // })
    // const result = joi.validate(opts, schema, {allowUnknown: true})
    // if (result.error) throw result.error
    // this.config = result.value
    this.config = config
    this._ipfs = this.config.ipfsInstance
  }

  /**
   * uploads a single file to *local* IPFS node
   * @param {File} file HTML5 File Object.
   * @returns {EventEmitter} checkout the upload function below for details.
   * @example let uploaderEv = paratiiIPFS.uploader.add(files)

   */
  add (file) {
    return new Promise((resolve, reject) => {
      let files
      if (Array.isArray(file)) {
        files = file
      } else {
        files = [file]
      }

      let result = []

      for (let i = 0; i &lt; files.length; i++) {
        // check if File is actually available or not.
        // if not it means we're not in the browser land.
        if (typeof File !== 'undefined') {
          if (files[i] instanceof File) {
            result.push(this.html5FileToPull(files[i]))
          } else {
            result.push(this.fsFileToPull(files[i]))
          }
        } else {
          result.push(this.fsFileToPull(files[i]))
        }
      }
      const ev = this.upload(result)
      ev.on('done', (hashedFiles) => resolve(hashedFiles))
      ev.on('error', (err) => reject(err))
    })
  }

  /**
   * upload an Array of files as is to the local IPFS node
   * @param  {Array} files    HTML5 File Object Array.
   * @return {EventEmitter} returns EventEmitter with the following events:
   *    - 'start': uploader started.
   *    - 'progress': (chunkLength, progressPercent)
   *    - 'fileReady': (file) triggered when a file is uploaded locally.
   *    - 'done': (files) triggered when the uploader is done locally.
   *    - 'error': (err) triggered whenever an error occurs.
   * @example ?
   */
  upload (files) {
    let meta = {} // holds File metadata.
    let ev = new EventEmitter()

    this._ipfs.start().then(() => {
      // trigger onStart callback
      ev.emit('start')
      if (files &amp;&amp; files[0] &amp;&amp; files[0].size > this.config.ipfs.maxFileSize) {
        ev.emit('error', `file size is larger than the allowed ${this.config.ipfs.maxFileSize / 1024 / 1024}MB`)
        return
      }

      pull(
        pull.values(files),
        pull.through((file) => {
          this._ipfs.log('Adding ', file)
          meta.fileSize = file.size
          meta.total = 0
        }),
        pull.asyncMap((file, cb) => pull(
          pull.values([{
            path: file.name,
            // content: pullFilereader(file)
            content: pull(
              file._pullStream,
              pull.through((chunk) => ev.emit('progress2', chunk.length, Math.floor((meta.total += chunk.length) * 1.0 / meta.fileSize * 100)))
            )
          }]),
          this._ipfs._node.files.addPullStream({chunkerOptions: {maxChunkSize: this.config.ipfs.chunkSize}}), // default size 262144
          pull.collect((err, res) => {
            if (err) {
              return ev.emit('error', err)
            }

            const hashedFile = res[0]
            this._ipfs.log('Adding %s finished as %s, size: %s', hashedFile.path, hashedFile.hash, hashedFile.size)

            if (file._html5File) {
              this.xhrUpload(file, hashedFile, ev)
            } else {
              ev.emit('fileReady', hashedFile)
            }

            cb(null, hashedFile)
          })
        )),
        pull.collect((err, hashedFiles) => {
          if (err) {
            ev.emit('error', err)
          }
          this._ipfs.log('uploader is DONE')
          ev.emit('done', hashedFiles)
        })
      )
    })

    return ev
  }

  /**
   * upload an entire directory to IPFS
   * @param  {string}   dirPath path to directory
   * @return {Promise}           returns the {multihash, path, size} for the uploaded folder.
   * @example ?
   */
  addDirectory (dirPath) {
    return new Promise((resolve, reject) => {
      // cb = once(cb)
      let resp = null
      // this._ipfs.log('adding ', dirPath, ' to IPFS')

      const addStream = this._ipfs._node.files.addReadableStream()
      addStream.on('data', (file) => {
        // this._ipfs.log('dirPath ', dirPath)
        // this._ipfs.log('file Added ', file)
        if (file.path === dirPath) {
          // this._ipfs.log('this is the hash to return ')
          resp = file
          nextTick(() => resolve(resp))
        }
      })

      addStream.on('end', () => {
        // this._ipfs.log('addStream ended')
        // nextTick(() => cb(null, resp))
      })

      fs.readdir(dirPath, (err, files) => {
        if (err) return reject(err)
        eachSeries(files, (file, next) => {
          next = once(next)
          try {
            this._ipfs.log('reading file ', file)
            let rStream = fs.createReadStream(path.join(dirPath, file))
            rStream.on('error', (err) => {
              if (err) {
                this._ipfs.error('rStream Error ', err)
                return next()
              }
            })
            if (rStream) {
              addStream.write({
                path: path.join(dirPath, file),
                content: rStream
              })
            }
          } catch (e) {
            if (e) {
              this._ipfs.error('createReadStream Error: ', e)
            }
          } finally {
          }
          // next()
          nextTick(() => next())
        }, (err) => {
          if (err) return reject(err)
          // addStream.destroy()
          addStream.end()
        })
      })
    })
  }
  /**
   * get file from ipfs
   * @param  {string}  hash ipfs multihash of the file
   * @return {Promise}      the file (path,content)
   * @example
   * let result = await paratiiIPFS.add(fileStream)
   * let hash = result[0].hash
   * let fileContent = await paratiiIPFS.get(hash)
   */
  async get (hash) {
    let ipfs = await this._ipfs.getIPFSInstance()
    return ipfs.files.get(hash)
  }

  /**
  * gets a JSON object stored in IPFS
  * @param  {string}  multihash ipfs multihash of the object
  * @return {Promise}           requested Object
  * @example let jsonObj = await paratii.ipfs.getJSON('some-multihash')
  */
  async getJSON (multihash) {
    let ipfs = await this._ipfs.getIPFSInstance()
    let node
    try {
      node = await ipfs.files.cat(multihash)
    } catch (e) {
      if (e) throw e
    }

    return JSON.parse(node.toString())
  }

  // /**
  //  * get an ipfs instance of jsipfs. Singleton pattern
  //  * @return {Object} Ipfs instance
  //  * @example ipfs = await paratii.ipfs.getIPFSInstance()
  //  */
  // getIPFSInstance () {
  //   return new Promise((resolve, reject) => {
  //     if (this.ipfs) {
  //       resolve(this.ipfs)
  //     } else {
  //       let config = this.config
  //       // there will be no joi in IPFS (pun indended)
  //       import(/* webpackChunkName: 'ipfs' */ 'ipfs') // eslint-disable-line
  //       .then((Ipfs) => {
  //         let ipfs = new Ipfs({
  //           bitswap: {
  //             // maxMessageSize: 256 * 1024
  //             maxMessageSize: this.config.ipfs['bitswap.maxMessageSize']
  //           },
  //           start: true,
  //           repo: config.ipfs.repo || '/tmp/test-repo-' + String(Math.random()),
  //           config: {
  //             Addresses: {
  //               Swarm: this.config.ipfs.swarm
  //               // [
  //               //   '/dns4/star.paratii.video/tcp/443/wss/p2p-webrtc-star',
  //               //   '/dns4/ws.star.paratii.video/tcp/443/wss/p2p-websocket-star/'
  //               // ]
  //             },
  //             Bootstrap: this.config.ipfs.bootstrap
  //             // [
  //             //   '/dns4/bootstrap.paratii.video/tcp/443/wss/ipfs/QmeUmy6UtuEs91TH6bKnfuU1Yvp63CkZJWm624MjBEBazW'
  //             // ]
  //           }
  //         })
  //
  //         this.ipfs = ipfs
  //
  //         ipfs.on('ready', () => {
  //           this.log('[IPFS] node Ready.')
  //
  //           ipfs._bitswap.notifications.on('receivedNewBlock', (peerId, block) => {
  //             this.log('[IPFS] receivedNewBlock | peer: ', peerId.toB58String(), ' block length: ', block.data.length)
  //             this.log('---------[IPFS] bitswap LedgerMap ---------------------')
  //             ipfs._bitswap.engine.ledgerMap.forEach((ledger, peerId, ledgerMap) => {
  //               this.log(`${peerId} : ${JSON.stringify(ledger.accounting)}\n`)
  //             })
  //             this.log('-------------------------------------------------------')
  //           })
  //
  //           ipfs.id().then((id) => {
  //             let peerInfo = id
  //             this.id = id
  //             this.log(`[IPFS] id:  ${peerInfo}`)
  //             let ptiAddress = (this.config.paratii &amp;&amp; this.config.paratii.eth.getAccount()) || 'no_address'
  //             this.protocol = new Protocol(
  //               ipfs._libp2pNode,
  //               ipfs._repo.blocks,
  //               // add ETH Address here.
  //               ptiAddress
  //             )
  //
  //             this._ipfs.remote._node = ipfs
  //             this._ipfs.local._node = ipfs
  //             this._ipfs.transcoder._node = ipfs
  //
  //             this.protocol.notifications.on('message:new', (peerId, msg) => {
  //               this.log('[paratii-protocol] ', peerId.toB58String(), ' new Msg: ', msg)
  //             })
  //             // emit all commands.
  //             // NOTE : this will be changed once protocol upgrades are ready.
  //             this.protocol.notifications.on('command', (peerId, command) => {
  //               this.emit('protocol:incoming', peerId, command)
  //             })
  //
  //             this.ipfs = ipfs
  //             this.protocol.start(() => {
  //               setTimeout(() => {
  //                 resolve(ipfs)
  //               }, 10)
  //             })
  //           })
  //         })
  //
  //         ipfs.on('error', (err) => {
  //           if (err) {
  //             // this.log('IPFS node ', ipfs)
  //             this.error('[IPFS] Error ', err)
  //             reject(err)
  //           }
  //         })
  //       })
  //     }
  //   })
  // }
  /**
   * adds a data Object to the IPFS local instance
   * @param  {Object}  data JSON object to store
   * @return {Promise}      promise with the ipfs multihash
   * @example let result = await paratiiIPFS.addJSON(data)
   */
  async addJSON (data) {
    let ipfs = await this._ipfs.getIPFSInstance()
    const obj = {
      Data: Buffer.from(JSON.stringify(data)),
      Links: []
    }
    let node
    try {
      // node = await ipfs.object.put(obj)
      node = await ipfs.files.add(obj.Data)
    } catch (e) {
      if (e) throw e
    }

    return node[0].hash
  }

  /**
   * returns a generic File Object with a Pull Stream from an HTML5 File
   * @param  {File} file  HTML5 File Object
   * @return {Object}      generic file object.
   * @example ?

   */
  html5FileToPull (file) {
    return {
      name: file.name,
      size: file.size,
      path: file.path,
      _html5File: file,
      _pullStream: pullFilereader(file)
    }
  }

  /**
   * returns a generic file Object from a file path
   * @param  {string} filePath Path to file.
   * @return {Object} generic file object.
   * @example ?

   */
  fsFileToPull (filePath) {
    let stats = fs.statSync(filePath)
    if (stats) {
      return {
        name: path.basename(filePath),
        size: stats.size,
        _pullStream: toPull(fs.createReadStream(filePath))
      }
    } else {
      return null
    }
  }

  /**
   * log messages on the console if verbose is set
   * @param  {string} msg text to log
   * @example
   * paratii.ipfs.log("some-text")
   */
  log (...msg) {
    if (this.config.verbose) {
      console.log(...msg)
    }
  }
  /**
   * log warns on the console if verbose is set
   * @param  {string} msg warn text
   * @example
   * paratii.ipfs.warn("some-text")
   */
  warn (...msg) {
    if (this.config.verbose) {
      console.warn(...msg)
    }
  }
  /**
  * log errors on the console if verbose is set
  * @param  {string} msg error message
  * @example
  * paratii.ipfs.error("some-text")
  */
  error (...msg) {
    if (this.config.verbose) {
      console.error(...msg)
    }
  }
}
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
	
		on 2018-04-11T16:00:55+02:00
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : false,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
