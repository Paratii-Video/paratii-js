<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"schemas.js.html":{"id":"schemas.js.html","title":"Source: schemas.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: schemas.js const joi = require('joi') /** * @typedef {Array} accountSchema * @property {?string} address public address of the account * @property {?string} privateKey private key of the account * @property {?string} mnemonic mnemonic that generates private key and address */ const accountSchema = joi.object({ address: joi.string().default(null).allow(null), privateKey: joi.string().default(null).allow(null), mnemonic: joi.string().default(null).allow(null) }).default() /** * @typedef {Array} ethSchema * @property {?string} provider provider of the parity node * @property {?string} registryAddress address of the TCR * @property {?boolean} isTestNet true if it's on test net, false otherwise */ const ethSchema = joi.object({ provider: joi.string().default('ws://localhost:8546'), registryAddress: joi.string().default(null).allow(null), isTestNet: joi.boolean().optional() }).default() /** * @typedef {Array} ipfsSchema * @property {?string} repo path to the ipfs repo * @property {Array} swarm available transports for ipfs (webrtc, websocket, ...) * @property {Array} bootstrap bootstrap nodes that ipfs connects to when it starts * @property {?number} bitswap.maxMessageSize the maximum msg size allowed for paratii-ipfs-bitswap * @property {?number} chunkSize max size allowed per file chunk * @property {?number} xhrChunkSize max chunk size for the express uploader * @property {?number} maxFileSize max size for an original video (default to 300MB) * @property {?string} defaultTranscoder the default multiaddress of the main paratii-node * @property {?string} remoteIFPFSNode the default multiaddress of the main paratii-node * @property {?string} transcoderDropUrl url for the express uploader */ const ipfsSchema = joi.object({ repo: joi.string().default(null).allow(null), // passed to IPFS constructor as `config.Addresses.Swarm` swarm: joi .array() .ordered( joi.string().default('/dns4/star.paratii.video/tcp/443/wss/p2p-webrtc-star'), joi.string().default('/dns/ws.star.paratii.video/wss/p2p-websocket-star/') ), bootstrap: joi .array() .ordered( joi.string().default('/dns4/bootstrap.paratii.video/tcp/443/wss/ipfs/QmeUmy6UtuEs91TH6bKnfuU1Yvp63CkZJWm624MjBEBazW') ), 'bitswap.maxMessageSize': joi.number().default(256 * 1024), chunkSize: joi.number().default(128 * 1024), xhrChunkSize: joi.number().default(1 * 1024 * 1024), maxFileSize: joi.number().default(300 * 1024 * 1024), defaultTranscoder: joi.string().default('/dns4/bootstrap.paratii.video/tcp/443/wss/ipfs/QmeUmy6UtuEs91TH6bKnfuU1Yvp63CkZJWm624MjBEBazW'), remoteIPFSNode: joi.string().default('/dns4/bootstrap.paratii.video/tcp/443/wss/ipfs/QmeUmy6UtuEs91TH6bKnfuU1Yvp63CkZJWm624MjBEBazW'), transcoderDropUrl: joi.string().default('https://uploader.paratii.video/api/v1/transcode') }).default() /** * @typedef {Array} dbSchema * @property {?string} provider provider of the db */ const dbSchema = joi.object({ provider: joi.string().default('https://db.paratii.video/api/v1/') }).default() /** * @typedef {Array} videoSchema * @property {?string} id univocal video identifier randomly generated * @property {?string} author author of the video * @property {?string} description description of the video * @property {?string} duration duration of the video * @property {?string} filename filename of the video * @property {number} filesize size of the video * @property {?string} free ? * @property {?string} ipfsHashOrig original ipfs multihash of the video * @property {?string} ipfsHash ipfs multihash of the video * @property {string} owner owner of the video * @property {?number} price price of the video * @property {?string} title title of the video * @property {Array} thumbnails thumbnails of the video * @property {?Object} storageStatus ? * @property {string} storageStatus.name ? * @property {?Object} storageStatus.data ? * @property {?Object} transcodingStatus ? * @property {string} transcodingStatus.name ? * @property {?Object} transcodingStatus.data ? * @property {?Object} uploadStatus ? * @property {string} uploadStatus.name ? * @property {?Object} uploadStatus.data ? */ const videoSchema = joi.object({ id: joi.string().default(null), author: joi.string().empty('').default('').allow(null), description: joi.string().empty('').default(''), duration: joi.string().empty('').default('').allow(null), filename: joi.string().empty('').default('').allow(null).allow(''), filesize: joi.number(), free: joi.string().empty('').default(null).allow(null), ipfsHashOrig: joi.string().empty('').default(''), ipfsHash: joi.string().empty('').default(''), owner: joi.string().required(), price: joi.number().default(0), // published: joi.any().default(false).allow(null), title: joi.string().empty('').default(''), thumbnails: joi.array(), storageStatus: joi.object({ name: joi.string().required(), data: joi.object().allow(null) }).optional().default({}), transcodingStatus: joi.object({ name: joi.string().required(), data: joi.object().allow(null) }).allow(null).default({}), uploadStatus: joi.object({ name: joi.string().required(), data: joi.object().allow(null) }).allow(null).default({}) }) export { accountSchema, ethSchema, ipfsSchema, dbSchema, videoSchema } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.js.html":{"id":"paratii.js.html","title":"Source: paratii.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.js import { ParatiiCore } from './paratii.core.js' import { ParatiiDb } from './paratii.db.js' import { ParatiiEth } from './paratii.eth.js' import { ParatiiIPFS } from './paratii.ipfs.js' import { ParatiiTranscoder } from './paratii.transcoder.js' import { ipfsSchema, ethSchema, accountSchema, dbSchema } from './schemas.js' const joi = require('joi') const utils = require('./utils.js') /** * Paratii library main object * The Paratii object serves as the general entry point for interacting with the family of Paratii * contracts that are deployed on the blockchain, utilities to run and interact with a local IPFS node, * and utilities to interact with the Paratii index. * @param {ParatiiConfigSchema} opts options object to configure paratii library * @property {ParatiiCoreVids} vids operations on videos * @property {ParatiiCoreUsers} users operations on users * @property {ParatiiEth} eth interact with the Ethereum blockchain * @property {ParatiiIPFS} ipfs interact with the IPFS instance * @property {ParatiiDb} db interact with the Paratii Index * @property {ParatiiTranscoder} transcoder commands for transcoding files * @example import Paratii from 'paratii-js' * paratii = new Paratii({ * eth: { * provider': 'http://localhost:8545' * }, * account: { * address: 'your-address' * } * }) */ class Paratii extends ParatiiCore { /** * @typedef {Array} ParatiiConfigSchema * @property {?accountSchema} account * @property {?ethSchema} eth * @property {?dbSchema} db * @property {?ipfsSchema} ipfs */ constructor (opts = {}) { const schema = joi.object({ account: accountSchema, eth: ethSchema, db: dbSchema, ipfs: ipfsSchema }) const result = joi.validate(opts, schema) if (result.error) throw result.error const config = result.value super(config) this.config = config this.config.paratii = this // this.core = this this.eth = new ParatiiEth(this.config) // this.core = new ParatiiCore(this.config) this.db = new ParatiiDb(this.config) this.ipfs = new ParatiiIPFS(this.config) this.transcoder = new ParatiiTranscoder(this.config) } /** * Sets the account that will be used to sign all transactions * @param {?string} address public address * @param {?string} privateKey private key related to the previous public address * @param {?string} mnemonic mnemonic related to the previous public address * @example paratii.eth.setAccount(null,'some-private-key') * @example paratii.eth.setAccount('some-address', null, 'some-mnemonic') */ // FIXME: we should take an object as arguments here setAccount (address, privateKey, mnemonic) { this.eth.setAccount(address, privateKey, mnemonic) } /** * Gets the ethereum address that is used to sign all the transactions * @example paratii.getAccount() */ getAccount () { this.eth.getAccount() } /** * Sets the address of the ParatiiRegistry contract * @param {string} address address of the ParatiiRegistry contract * @example paratii.eth.setRegistryAddress('0x12345') */ setRegistryAddress (address) { return this.eth.setRegistryAddress(address) } /** * Sets the address of the ParatiiRegistry contract * @param {string} address address of the ParatiiRegistry contract * @example paratii.getRegistryAddress() */ getRegistryAddress (address) { return this.eth.getRegistryAddress() } /** * Get some diagnostic info about the state of the system * @return {Promise} that resolves in an array of strings with diagnostic info * @example let diagnosticInfo = await paratii.diagnose() * console.log(diagnosticInfo) */ async diagnose () { let msg, address, msgs let isOk = true msgs = [] function log (msg) { msgs.push(msg) } log('Paratii was initialized with the following options:') log(this.config) log('Checking main account') if (this.config.account.address &amp;&amp; this.config.account.privateKey) { log(`Your private key: ${this.config.account.privateKey}`) log(`Your private key: ${this.config.account.privateKey}`) log(`First wallet account: ${this.eth.web3.eth.accounts.wallet[0].address}`) } address = this.eth.getRegistryAddress() if (!address) { log('*** No registry address found!') log(`Value of this.config['eth.registryAddress']: ${this.config['eth.registryAddress']}`) isOk = false } else { log('checking deployed code of Registry...') msg = await this.eth.web3.eth.getCode(address) if (msg === '0x') { log(`ERROR: no code was found on the registry address ${address}`) log(msg) } else { log('... seems ok...') // log(`We found the following code on the registry address ${address}`) // log(msg) } log(`checking for addresses on registry@${address}`) let registry = await this.eth.getContract('Registry') log(`(registry address is ${registry.options.address})`) for (var name in this.eth.contracts) { if (name !== 'Registry') { address = await registry.methods.getContract(name).call() log(`address of ${name}: ${address}`) } } } if (isOk) { log('---- everything seems fine -----') } else { log('***** Something is wrong *****') } return msgs } } export default Paratii export { Paratii, utils, ParatiiIPFS, ParatiiDb, ParatiiEth } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.core.users.js.html":{"id":"paratii.core.users.js.html","title":"Source: paratii.core.users.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.core.users.js const joi = require('joi') /** * Utilities to create and manipulate information about the users on the blockchain. * @param {Object} config configuration object to initialize Paratii object */ export class ParatiiCoreUsers { constructor (config) { // const schema = joi.object({ // 'db.provider': joi.string().default(null) // }).unknown() // // const result = joi.validate(config, schema) // // const error = result.error // if (error) throw error this.config = config } /** * Creates a user, fields id, name and email go to the smart contract Users, other fields are stored on IPFS. * @param {userSchema} options information about the video ( id, name, email ... ) * @return {Promise} the id of the newly created user * @example * paratii.users.create({ * id: 'some-user-id', * name: 'A user name', * email: 'some@email.com', * ... * }) */ // FIXME: do some joi validation here async create (options) { let keysForBlockchain = ['id', 'name', 'email'] let optionsKeys = Object.keys(options) let optionsBlockchain = {} let optionsIpfs = {} optionsKeys.forEach(function (key) { if (keysForBlockchain.includes(key)) { optionsBlockchain[key] = options[key] } else { optionsIpfs[key] = options[key] } }) let hash = await this.config.paratii.ipfs.local.addJSON(optionsIpfs) optionsBlockchain['ipfsData'] = hash return this.config.paratii.eth.users.create(optionsBlockchain) } /** * retrieve data about the user * @param {string} id user univocal id * @return {Object} data about the user * @example paratii.users.get('some-user-id') */ get (id) { return this.config.paratii.db.users.get(id) } /** * Updates a user's details. name and email are defined in the smart contract Users, other fields get written to IPFS. * @param {string} userId user univocal id * @param {Object} options updated data i.e. { name: 'A new user name' } * @return {Promise} updated data about the user * @example paratii.users.update('some-user-id', {name: 'A new user name'}) */ async update (userId, options) { const schema = joi.object({ name: joi.string().default(null), email: joi.string().default(null) }) const result = joi.validate(options, schema) const error = result.error if (error) throw error options = result.value let data = await this.get(userId) for (let key in options) { if (options[key] !== null) { data[key] = options[key] } } data['id'] = userId await this.create(data) return data } /** * migrate all contract data for paratii.config.account to a new account * @param newAccount Address of new account * @async */ async migrateAccount (newAccount) { // migrate the videos const paratii = this.config.paratii const oldAccount = this.config.account.address const vids = await paratii.vids.search({owner: oldAccount}) for (let i in vids) { let vid = vids[i] let videoId = vid.id || vid._id await paratii.vids.update(videoId, {owner: newAccount}) let didVideoApply = await paratii.eth.tcr.didVideoApply(vid.id) if (didVideoApply) { // removing video from statke await paratii.eth.tcr.exit(videoId) } } // transfer all PTI to the new account let ptiBalance = await paratii.eth.balanceOf(oldAccount, 'PTI') await paratii.eth.transfer(newAccount, ptiBalance, 'PTI') // FIXME: need to call tc.apply(vid.id) with newAccount as sender (how to do that?) } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.core.vids.js.html":{"id":"paratii.core.vids.js.html","title":"Source: paratii.core.vids.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.core.vids.js import { videoSchema } from './schemas.js' import joi from 'joi' /** * Utilities to create and manipulate information about the videos on the blockchain. * @param {Object} config configuration object to initialize Paratii object */ export class ParatiiCoreVids { constructor (config) { this.config = config } /** * This call will register the video on the blockchain, add its metadata to IPFS, upload file to IPFS, and transcode it * @param {videoSchema} options information about the video ( id, title, FilePath ... ) * @return {Promise} information about the video ( id, owner, ipfsHash ... ) * @example await paratii.core.vids.create({ * id: 'some-video-id', * owner: 'some-user-id', * title: 'some Title', * author: 'Steven Spielberg', * duration: '2h 32m', * description: 'A long description', * price: 0, * filename: 'test/data/some-file.txt' * }) */ async create (options = {}) { const result = joi.validate(options, videoSchema) const error = result.error if (error) throw error options = result.value if (options.id === null) { options.id = this.config.paratii.eth.vids.makeId() } let hash = await this.config.paratii.ipfs.addAndPinJSON({ author: options.author, description: options.description, duration: options.duration, filename: options.filename, filesize: options.filesize, free: options.free, storageStatus: options.storageStatus, title: options.title, transcodingStatus: options.transcodingStatus, uploadStatus: options.uploadStatus, thumbnails: options.thumbnails }) options.ipfsData = hash await this.config.paratii.eth.vids.create({ id: options.id, owner: options.owner, price: options.price, ipfsHashOrig: options.ipfsHashOrig, ipfsHash: options.ipfsHash, ipfsData: options.ipfsData }) return options } /** * Writes a like for the video on the blockchain (contract Likes), and negates a dislike for the video, if it exists. * @param {string} videoId univocal video identifier randomly generated * @return {Object} information about the transaction recording the like * @example paratii.core.vids.like('some-video-id') */ like (videoId) { return this.config.paratii.eth.vids.like(videoId) } /** * Writes a dislike for the video on the blockchain (contract Likes), and negates a like for the video, if it exists. * @param {string} videoId univocal video identifier randomly generated * @return {Object} information about the transaction recording the dislike * @example paratii.core.vids.dislike('some-video-id') */ dislike (videoId) { return this.config.paratii.eth.vids.dislike(videoId) } /** * Check if the current user has already liked the video * @param {string} videoId univocal video identifier randomly generated * @return {Boolean} true if the current user already liked the video, false otherwise * @example paratii.core.vids.doesLike('some-video-id') */ doesLike (videoId) { return this.config.paratii.eth.vids.doesLike(videoId) } /** * Check if the viewer has already viewed the video * @param {string} viewer viewer address * @param {string} videoId univocal video identifier randomly generated * @return {Boolean} true if the current user already viewed the video, false otherwise * @example paratii.core.vids.hasViewedVideo('some-user-id','some-video-id') */ hasViewedVideo (viewer, videoId) { return this.config.paratii.eth.vids.userViewedVideo({ viewer: viewer, videoId: videoId }) } /** * Check if the current user has already disliked the video * @param {string} videoId univocal video identifier randomly generated * @return {Boolean} true if the current user already disliked the video, false otherwise * @example paratii.core.vids.doesDislike('some-video-id') */ doesDislike (videoId) { return this.config.paratii.eth.vids.doesDislike(videoId) } /** * Update the information on the video. * Only the account that has registered the video, or the owner of the contract, can update the information. * @param {string} videoId univocal video identifier * @param {Object} options key value pairs of properties and new values e.g. ({title: 'another-title'}) * @param {Object} dataToUpdate optional. old data of the video. If not passed to the method, it will fetch the data itself using the videoId * @return {Promise} Updated video informations * @example paratii.core.vids.update('some-video-id', {title: 'another-title'}) */ async update (videoId, options, dataToUpdate) { let data if (dataToUpdate) { data = dataToUpdate } else { data = await this.get(videoId) } if (data === null) { throw new Error(`No video with id ${videoId} to update`) } // FIXME: missing the validate invociation const elements = videoSchema._inner.children let dataToSave = {} elements.forEach(function (name) { const key = name.key if (options[key] !== undefined) { dataToSave[key] = options[key] } else { dataToSave[key] = data[key] } }) await this.create(dataToSave) return dataToSave } /** * Update the information of the video the video already exists, otherwise it creates it * @param {Object} options video informations * @return {Promise} updated/new video informations * @example * paratii.vids.upsert({ id: 'some-video-id', owner: 'some-user-id', title: 'videoTitle'}) //insert a new video */ async upsert (options) { let data = null if (options.id) { data = await this.get(options.id) } if (!data) { return this.create(options) } else { return this.update(options.id, options, data) } } /** * Register a view on the blockchain * @param {Object} options should contain keys viewer (address of the viewer) and videoId (univocal video identifier) * @return {Promise} information about the transaction recording the view * @example paratii.core.vids.view({viewer:'some-user-id',videoId: 'some-video-id'}) */ async view (options) { let keysForBlockchain = ['viewer', 'videoId'] let optionsKeys = Object.keys(options) let optionsBlockchain = {} let optionsIpfs = {} optionsKeys.forEach(function (key) { if (keysForBlockchain.includes(key)) { optionsBlockchain[key] = options[key] } else { optionsIpfs[key] = options[key] } }) let hash = await this.config.paratii.ipfs.local.addJSON(optionsIpfs) optionsBlockchain['ipfsData'] = hash return this.config.paratii.eth.vids.view(optionsBlockchain) } /** * Get the data of the video identified by videoId * @param {string} videoId univocal video identifier randomly generated * @return {Promise} data about the video * @example paratii.core.vids.get('some-video-id') */ async get (videoId) { return this.config.paratii.db.vids.get(videoId) } /** * Get the data of the video * @param {Object} options data about the video and (optional) owner i.e {'keyword':'titleOfTheVideo'} * @return {Promise} data about the video * @example paratii.core.vids.search({keyword : 'titleOftheVideo'}) * the keyword value can be one from the following list * - video title * - description * - owner * - uploader.name * - uploader.address * - tags */ search (options) { return this.config.paratii.db.vids.search(options) } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.db.js.html":{"id":"paratii.db.js.html","title":"Source: paratii.db.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.db.js import { ParatiiDbVids } from './paratii.db.vids.js' import { ParatiiDbUsers } from './paratii.db.users.js' import { dbSchema, accountSchema } from './schemas.js' import joi from 'joi' /** * ParatiiDb contains a functionality to interact with the Paratii Index. * @param {ParatiiDbSchema} config configuration object to initialize Paratii object * @property {ParatiiCoreVids} vids operations on videos * @property {ParatiiCoreUsers} users operations on users */ export class ParatiiDb { /** * @typedef ParatiiDbSchema * @property {dbSchema} db * @property {accountSchema} account */ constructor (config) { const schema = { db: dbSchema, account: accountSchema } const result = joi.validate(config, schema, {allowUnknown: true}) if (result.error) throw result.error this.config = config this.config.db = result.value.db this.config.account = result.value.account this.vids = new ParatiiDbVids(this.config) this.users = new ParatiiDbUsers(this.config) } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.db.users.js.html":{"id":"paratii.db.users.js.html","title":"Source: paratii.db.users.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.db.users.js const fetch = require('isomorphic-fetch') /** * ParatiiDbUsers contains functionalities regarding the users to interact with the Paratii Blockchain Index * @param {Object} config object to initialize Paratii object */ export class ParatiiDbUsers { constructor (config) { this.config = config this.apiUsers = 'users/' this.apiVideos = '/videos' } /** * retrieve data about the user * @param {string} userId user univocal id * @return {Promise} data about the user * @example paratii.db.users.get('some-user-id') */ async get (userId) { let users = await fetch(this.config.db.provider + this.apiUsers + userId, { method: 'get' }).then(function (response) { return response.json() }) return users } /** * get information about all the videos of the user * @param {string} userId univocal user identifier * @return {Promise} Collection of all the videos of the user * @example paratii.db.users.videos('some-user-id') */ async videos (userId) { let users = await fetch(this.config.db.provider + this.apiVersion + this.apiUsers + userId + this.apiVideos, { method: 'get' }).then(function (response) { return response.json() }) console.log(users) return users } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.db.vids.js.html":{"id":"paratii.db.vids.js.html","title":"Source: paratii.db.vids.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.db.vids.js const joi = require('joi') const fetch = require('isomorphic-fetch') /** * ParatiiDbUsers contains functionalities regarding the videos to interact with the Paratii Blockchain Index * @param {Object} config object to initialize Paratii object */ export class ParatiiDbVids { constructor (config) { this.config = config this.apiVideos = 'videos/' } /** * Get information about this video from the db * @param {string} videoId univocal video identifier randomly generated * @return {Promise} data about the video * @example paratii.db.vids.get('some-video-id') */ async get (videoId) { let videos = await fetch(this.config.db.provider + this.apiVideos + videoId, { method: 'get' }).then(function (response) { return response.json() }) return videos } /** * Get the data of the video * @param {Object} options data about the video and (optional) owner i.e {'keyword':'titleOfTheVideo'} * @return {Promise} data about the video * @example paratii.db.vids.search({keyword : 'titleOftheVideo'}) * the keyword value can be one from the following list * - video title * - description * - owner * - uploader.name * - uploader.address * - tags */ async search (options) { // FIXME: does not handle combinations of parameters yet const schema = joi.object({ 'owner': joi.string().empty(), 'keyword': joi.string().empty() }) const result = joi.validate(options, schema) const error = result.error if (error) throw error let k = '' for (let keyword in options) { k = `${keyword}=${options[keyword]}` } if (k !== '') { k = `?${k}` } let videos = await fetch(this.config.db.provider + this.apiVideos + k, { method: 'get' }).then(function (response) { return response.json() }) return videos } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.eth.js.html":{"id":"paratii.eth.js.html","title":"Source: paratii.eth.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.eth.js import { add0x } from './utils.js' import { ParatiiEthVids } from './paratii.eth.vids.js' import { ParatiiEthUsers } from './paratii.eth.users.js' import { ParatiiEthEvents } from './paratii.eth.events.js' import { ParatiiEthVouchers } from './paratii.eth.vouchers.js' import { ParatiiEthTcr } from './paratii.eth.tcr.js' import { patchWallet } from './paratii.eth.wallet.js' import { ethSchema, accountSchema } from './schemas.js' import joi from 'joi' const Web3 = require('web3') // const joi = require('joi') /** * contains functions to interact with the Ethereum blockchain and the Paratii contracts. * See {@link Paratii} * @param {ParatiiEthSchema} config configuration object to initialize Paratii object * @property {ParatiiCoreVids} vids operations on videos * @property {ParatiiCoreUsers} users operations on users * @property {ParatiiEthEvents} events manage subscriptions to Ethereum events * @property {ParatiiEthVouchers} vouchers Functions for redeeming vouchers * @property {ParatiiEthTcr} tcr TCR functionality * @example let paratii = new Paratii() * // paratii.eth is an instance of ParatiiEth; let's check the PTI balance of an account * paratii.eth.balanceOf('0xCbe4f07b343171ac37055B25a5266f48f6945b7d', 'PTI') */ export class ParatiiEth { /** * @typedef {Array} ParatiiEthSchema * @property {?accountSchema} account * @property {?ethSchema} eth */ constructor (config) { const schema = joi.object({ account: accountSchema, eth: ethSchema // web3: joi.any().default(null) }) const result = joi.validate(config, schema, {allowUnknown: true}) if (result.error) throw result.error config.eth = result.value.eth config.account = result.value.account if (config.eth.provider.match(/(localhost|127\\.0\\.0\\.1)/g)) { config.eth.isTestNet = true } else { config.eth.isTestNet = false } if (config.web3) { this.web3 = config.web3 } else { this.web3 = new Web3() if (config.eth.provider.substring(0, 2) === 'ws') { this.web3.setProvider(new this.web3.providers.WebsocketProvider(config.eth.provider)) } else { this.web3.setProvider(new this.web3.providers.HttpProvider(config.eth.provider)) } } this.config = config this.wallet = patchWallet(this.web3.eth.accounts.wallet, this.config) this.setAccount(this.config.account.address, this.config.account.privateKey, this.config.account.mnemonic) this.contracts = {} this.contracts.ParatiiToken = this.requireContract('ParatiiToken') this.contracts.Avatar = this.requireContract('Avatar') this.contracts.Registry = this.requireContract('Registry') this.contracts.SendEther = this.requireContract('SendEther') this.contracts.Users = this.requireContract('Users') this.contracts.Videos = this.requireContract('Videos') this.contracts.Store = this.requireContract('Store') this.contracts.Likes = this.requireContract('Likes') this.contracts.Views = this.requireContract('Views') this.contracts.Vouchers = this.requireContract('Vouchers') this.contracts.TcrPlaceholder = this.requireContract('TcrPlaceholder') this.vids = new ParatiiEthVids(this) this.users = new ParatiiEthUsers(this) this.events = new ParatiiEthEvents(this) this.vouchers = new ParatiiEthVouchers(this) this.tcr = new ParatiiEthTcr(this) } /** * creates an account using the private key or, if not present, using the mnemonic * @param {string} address public address * @param {string} privateKey private key related to the previous public address * @param {string} mnemonic mnemonic related to the previous public address * @example paratii.eth.setAccount('some-address','some-private-key') * @example paratii.eth.setAccount('some-address','some-mnemonic') * SEE paratii.setAccount() * @private */ setAccount (address, privateKey, mnemonic) { const wallet = this.web3.eth.accounts.wallet this.config.account.address = address this.config.account.privateKey = privateKey this.web3.eth.testAccount = address if (privateKey) { let account = wallet.add(privateKey) if (account.address !== address) { throw Error('Private Key and Account address are not compatible!') } this.config.account.address = address this.config.account.privateKey = privateKey } else if (mnemonic) { wallet.create(1, mnemonic) if (address &amp;&amp; wallet[0].address !== address) { throw Error(`Mnemonic ${mnemonic} and account address ${address} are not compatible!`) } this.config.account.address = wallet[0].address this.config.account.privateKey = wallet[0].privateKey } } /** * Get the account * @example getAccount() * @memberof paratii.eth * @private */ getAccount () { const wallet = this.web3.eth.accounts.wallet return wallet.length &gt; 0 &amp;&amp; wallet[0].address } /** * Get the contract instance specified * @param {string} name the name of the token * @return {Promise} Object representing the contract * @example paratii.eth.getContract('ParatiiToken') */ async getContract (name) { let contract = this.contracts[name] if (!contract) { throw Error(`No contract with name &quot;${name}&quot; is known`) } if (!contract.options.address) { let address = await this.getContractAddress(name) if (address &amp;&amp; address !== '0x0') { contract.options.address = address } } if (!contract.methods.constructor._ethAccounts) { contract.methods.constructor._ethAccounts = this.web3.eth.accounts } contract.options.from = this.config.account.address return contract } /** * creates the javascript contract object from the json file * @param {string} contractName name of the contract * @return {string} Contract Object * @example paratii.eth.requireContract('ParatiiToken') * @private */ requireContract (contractName) { const artifact = require(`paratii-contracts/build/contracts/${contractName}.json`) let from = this.config.account.address const contract = new this.web3.eth.Contract( artifact.abi, { from: from, gas: this.web3.utils.toHex(4e6), data: artifact.bytecode }) // contract.setProvider(this.web3.currentProvider, this.web3.eth.accounts) return contract } /** * deploys contract on the blockchain * @param {string} name name of the contract * @param {Object} args configuration for the contract (strings or numbers). It is allowed to pass more than one parameter * @return {Promise} the deployed contract * @example paratii.eth.deployContract('ParatiiToken') * @example let paratiiRegistryAddress = await paratii.eth.getRegistryAddress() * let likes = await this.deployContract('Likes', paratiiRegistryAddress) */ async deployContract (name, ...args) { if (!this.config.account.address) { let msg = 'You need an Ethereum account to write information to the blockchain - you can use .setAccount(address, [privateKey]) or specify it when creating the object' throw Error(msg) } let contract = await this.getContract(name) let deployedContract = await contract.deploy({arguments: args}).send() deployedContract.setProvider(this.web3.currentProvider, this.web3.eth.accounts) this.contracts[name] = deployedContract return deployedContract } /** * deploy all Paratii contracts on the blockchain, and register them the registry contract * @return {Promise} all the paratii contracts * @example let contracts = await paratii.eth.deployContracts() * for (contractName in contracts) { console.log(contracts[contractName])} */ async deployContracts () { let paratiiRegistry = await this.deployContract('Registry') let paratiiRegistryAddress = paratiiRegistry.options.address await this.setRegistryAddress(paratiiRegistry.options.address) let paratiiAvatar = await this.deployContract('Avatar', paratiiRegistryAddress) let paratiiToken = await this.deployContract('ParatiiToken') let sendEther = await this.deployContract('SendEther') let userRegistry = await this.deployContract('Users', paratiiRegistryAddress) let videoRegistry = await this.deployContract('Videos', paratiiRegistryAddress) let videoStore = await this.deployContract('Store', paratiiRegistryAddress) let likes = await this.deployContract('Likes', paratiiRegistryAddress) let views = await this.deployContract('Views', paratiiRegistryAddress) let vouchers = await this.deployContract('Vouchers', paratiiRegistryAddress) let tcrPlaceholder = await this.deployContract('TcrPlaceholder', paratiiRegistryAddress, paratiiToken.options.address, this.web3.utils.toWei('5'), 100) paratiiRegistry = await this.getContract('Registry') await paratiiRegistry.methods.registerAddress('Avatar', paratiiAvatar.options.address).send() await paratiiRegistry.methods.registerAddress('ParatiiToken', paratiiToken.options.address).send() await paratiiRegistry.methods.registerAddress('SendEther', sendEther.options.address).send() await paratiiRegistry.methods.registerAddress('Videos', videoRegistry.options.address).send() await paratiiRegistry.methods.registerAddress('Store', videoStore.options.address).send() await paratiiRegistry.methods.registerAddress('Users', userRegistry.options.address).send() await paratiiRegistry.methods.registerAddress('Likes', likes.options.address).send() await paratiiRegistry.methods.registerAddress('Views', views.options.address).send() await paratiiRegistry.methods.registerAddress('Vouchers', vouchers.options.address).send() await paratiiRegistry.methods.registerAddress('TcrPlaceholder', tcrPlaceholder.options.address).send() await paratiiRegistry.methods.registerUint('VideoRedistributionPoolShare', this.web3.utils.toWei('0.3')) await paratiiAvatar.methods.addToWhitelist(videoStore.address) this.contracts = { Avatar: paratiiAvatar, Registry: paratiiRegistry, ParatiiToken: paratiiToken, SendEther: sendEther, Users: userRegistry, Videos: videoRegistry, Likes: likes, Views: views, Vouchers: vouchers, Store: videoStore, TcrPlaceholder: tcrPlaceholder } this.setRegistryAddress(paratiiRegistryAddress) return this.contracts } /** * Set the provider on all the contracts * @example paratii.eth.setContractsProvider() * @private */ async setContractsProvider () { for (var key in this.contracts) { this.contracts[key].setProvider(this.web3.currentProvider, this.web3.eth.accounts) } } /** * return all the contracts * @return {Promise} * @example let contracts = await paratii.eth.getContracts() * @example let contracts = await paratii.eth.deployContracts() * for (contractName in contracts) { console.log(contracts[contractName])} */ async getContracts () { for (var name in this.contracts) { let contract = this.contracts[name] if (!contract.options.address) { let address = await this.getContractAddress(name) if (address &amp;&amp; address !== '0x0') { contract.options.address = address } } } return this.contracts } /** * get the address of the contract on the blockchain * @param {string} name name of the contract * @return {Promise} Contract address on the blockchain (String) * @example paratii.eth.getContractAddress('ParatiiToken') */ async getContractAddress (name) { let registryAddress = this.getRegistryAddress() if (name === 'Registry') { return registryAddress } if (!registryAddress) { throw Error('No registry address configured') } try { let registry = await this.getContract('Registry') if (!registry) { throw Error('No registry contract!') } let address = await registry.methods.getContract(name).call() return address } catch (err) { throw err } } /** * get the address of the Registry contract on the blockchain * @return {string} address on the blockchain * @example let registryAddress = paratii.eth.getRegistryAddress() * @private */ getRegistryAddress () { return this.config.eth.registryAddress } /** * set the address of the Registry contract on the blockchain * @param {string} registryAddress new address * @example await paratii.eth.setRegistryAddress('some-address') * @private */ setRegistryAddress (registryAddress) { this.config.eth.registryAddress = registryAddress for (var name in this.contracts) { let contract = this.contracts[name] contract.options.address = undefined } } /** * When called with a second argument, returns the balance of that Token.&lt;br&gt; * When called without a second argument, returns information about all relevant balances. * @param {string} address ethereum address * @param {string} [symbol] symbol of the token (ETH,PTI) * @return {Promise} information about balances of that address * @example * // returns the ETH balance of the given address * await paratii.eth.balanceOf('some-address', 'ETH') * // returns the PTI balance of the given address * await paratii.eth.balanceOf('some-address', 'PTI') * // returns both the PTI and the ETH balance of the given address * await paratii.eth.balanceOf('some-address') */ async balanceOf (address, symbol) { let balance let balances = {} if (symbol &amp;&amp; !(['PTI', 'ETH'].includes(symbol))) { throw Error(`Unknown symbol &quot;${symbol}&quot;, must be one of &quot;ETH&quot;, &quot;PTI&quot;`) } if (!symbol || symbol === 'ETH') { balance = await this.web3.eth.getBalance(address) balances.ETH = balance } if (!symbol || symbol === 'PTI') { let contract = await this.getContract('ParatiiToken') balance = await contract.methods.balanceOf(address).call() balances.PTI = balance } if (symbol) { return balance } else { return balances } } /** * send ETH from current account to beneficiary * @param {string} beneficiary ETH address * @param {number} amount amount of ETH to be sent * @param {?string} description description of the transaction (will be written in the blockchain) * @return {Promise} information about the transaction recording the transfer * @example return paratii.eth._transferETH('some-address', 20, 'an-optional-description') * @private */ async _transferETH (beneficiary, amount, description) { const contract = await this.getContract('SendEther') if (!contract.options || !contract.options.address) { throw Error('No SendEther contract known - please run paratii.diagnose()') } let from = this.config.account.address if (!from) { throw Error('No account set! Cannot send transactions') } if (!description) { description = '' } from = add0x(from) beneficiary = add0x(beneficiary) try { return await contract.methods.transfer(beneficiary, description).send({value: amount}) } catch (err) { throw err } } /** * send PTI from current account to beneficiary * @param {string} beneficiary ETH address * @param {number} amount amount of PTI to be sent * @return {Promise} information about the transaction recording the transfer * @example return paratii.eth._transferPTI('some-address', 20) * @private */ async _transferPTI (beneficiary, amount) { const contract = await this.getContract('ParatiiToken') if (!contract.options || !contract.options.address) { throw Error('No ParatiiToken contract known - please run paratii.diagnose()') } let from = this.config.account.address if (!from) { throw Error('No account set! Cannot send transactions') } from = add0x(from) beneficiary = add0x(beneficiary) let result = await contract.methods.transfer(beneficiary, amount).send() return result } /** * Use this to send ETH or PTI from paratii.config.address * @param {string} beneficiary ETH address * @param {number} amount amount of ETH/PTI to be sent * @param {string} symbol symbol of the token to send (ETH,PTI) * @param {?string} description description to be inserted in the blockchain * @return {Promise} information about the transaction recording the transfer * @example let result = await paratii.eth.transfer('some-address', 20, 'ETH', 'thanks for all the fish') */ async transfer (beneficiary, amount, symbol, description) { if (symbol === 'ETH') { return this._transferETH(beneficiary, amount, description) } else if (symbol === 'PTI') { return this._transferPTI(beneficiary, amount) } } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.eth.events.js.html":{"id":"paratii.eth.events.js.html","title":"Source: paratii.eth.events.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.eth.events.js /** * eth.events implements a part of the API of the EventEmitter, that can be used to manage subscriptions to Ethereum events. * @param {Object} config configuration object to initialize Paratii object */ export class ParatiiEthEvents { constructor (config) { this.config = config this._subscriptions = {} this.subscribe = config.web3.eth.subscribe this._customEvents = { TransferPTI: { contract: 'ParatiiToken', event: 'Transfer' }, TransferETH: { contract: 'SendEther', event: 'LogSendEther' }, CreateVideo: { contract: 'Videos', event: 'LogCreateVideo' }, UpdateVideo: { contract: 'Videos', event: 'LogCreateVideo' }, RemoveVideo: { contract: 'Videos', event: 'LogRemoveVideo' }, BuyVideo: { contract: 'Store', event: 'LogBuyVideo' }, CreateUser: { contract: 'Users', event: 'LogCreateUser' }, RemoveUser: { contract: 'Users', event: 'LogRemoveUser' }, CreateVoucher: { contract: 'Vouchers', event: 'LogCreateVoucher' }, RemoveVoucher: { contract: 'Vouchers', event: 'LogRemoveVoucher' }, RedeemVoucher: { contract: 'Vouchers', event: 'LogRedeemVoucher' }, Application: { contract: 'TcrPlaceholder', event: '_Application' }, NewVideoWhitelisted: { contract: 'TcrPlaceholder', event: '_NewVideoWhitelisted' } } } /** * parse event from simple string to an object * @param {string} eventType Event type * @return {Object} Event Object * @example let structuredEvent = this._getStructuredEvent('some-event') */ _getStructuredEvent (eventType) { let structuredEvent = {} if (eventType.substr(eventType.length - 5).toLowerCase().indexOf('error') !== -1) { // error event structuredEvent.event = eventType.substr(0, eventType.length - 5) structuredEvent.emit = 'error' } else if (eventType.substr(eventType.length - 7).toLowerCase().indexOf('changed') !== -1) { // changed event structuredEvent.event = eventType.substr(0, eventType.length - 7) structuredEvent.emit = 'changed' } else { // data event structuredEvent.event = eventType structuredEvent.emit = 'data' } return structuredEvent } /** * subscribe to the specified event * @param {string} eventType type of the event * @param {Function} options function called when the events occurs * @param {?} listener optional ? * @return {Promise} [description] */ async addListener (eventType, options, listener) { if (this._isFunction(options)) { return this._addListener(eventType, options) } else { return this._addListener(eventType, listener, options) } } /** * [_addListener description] * TODO RIVEDI I TIPI * @param {Object} eventType [description] * @param {Object} listener [description] * @param {Object} options [description] * @return {Promise} [description] */ async _addListener (eventType, listener, options) { let structuredEvent = this._getStructuredEvent(eventType) let subscription = null switch (structuredEvent.event) { case 'newBlockHeaders': case 'syncing': case 'pendingTransactions': { subscription = await this.subscribe(eventType) subscription.on(structuredEvent.emit, listener) break } case 'logs': { if (options === undefined) { options = { fromBlock: null, topics: null } } subscription = this.subscribe('logs', options) subscription.on(structuredEvent.emit, listener) break } default: { let contract = await this.config.getContract(this._customEvents[structuredEvent.event].contract) subscription = await contract.events[this._customEvents[structuredEvent.event].event](options) subscription.on(structuredEvent.emit, listener) } } return this.addSubscription(eventType, subscription) } /** * [_isFunction description] * TODO RIVEDI I TIPI * @param {Object} functionToCheck [description] * @return {Boolean} [description] */ _isFunction (functionToCheck) { var getType = {} return functionToCheck &amp;&amp; getType.toString.call(functionToCheck) === '[object Function]' } /** * [addSubscription description] * TODO RIVEDI I TIPI * @param {Object} eventType [description] * @param {Object} subscription [description] */ addSubscription (eventType, subscription) { if (!this._subscriptions[eventType]) { this._subscriptions[eventType] = [] } // const key = this._subscriptions[eventType].length subscription.eventType = eventType // subscription.id = key // console.log(subscription) this._subscriptions[eventType].push(subscription) return subscription } /** * [removeAllSubscriptions description] * TODO RIVEDI I TIPI * @param {Object} eventType [description] * @return {Object} [description] */ removeAllSubscriptions (eventType) { if (eventType === undefined) { this._subscriptions = {} } else { delete this._subscriptions[eventType] } } // // getSubscriptionsForType (eventType) { // return this._subscriptions[eventType] // } // // removeSubscription (subscription) { // const eventType = subscription.eventType // const key = subscription.key // // const subscriptionsForType = this._subscriptions[eventType] // if (subscriptionsForType) { // delete subscriptionsForType[key] // } // } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.eth.tcr.js.html":{"id":"paratii.eth.tcr.js.html","title":"Source: paratii.eth.tcr.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.eth.tcr.js 'use strict' import { getInfoFromLogs } from './utils.js' /** * Token Curated Registry functionalities * @param {Object} context ParatiiEth instance * @property {ParatiiEth} eth ParatiiEth instance */ export class ParatiiEthTcr { constructor (context) { this.eth = context } /** * get TCR contract instance. * @return {Promise} The TCR Contract instance. * @example let contract = await paratii.eth.tcr.getTcrContract() */ async getTcrContract () { let contract = await this.eth.getContract('TcrPlaceholder') if (contract.options.address === '0x0') { throw Error('There is no TCR contract known in the registry') } return contract } /** * get the minimum amount required to stake a video. * @return {Float} amount required in PTI * @todo return amount as bignumber.js Object * @example let minDeposit = await paratii.eth.tcr.getMinDeposit() */ async getMinDeposit () { let contract = await this.getTcrContract() let minDeposit = await contract.methods.getMinDeposit().call() return minDeposit } /** * check if video is already whitelisted or not. note that this returns false * till the video is actually whitelisted. use didVideoApply in case you want * to check whether the video is in application process. * @param {string} videoId univocal video identifier randomly generated * @return {boolean} true if video is whitelisted, false otherwise * @example let isWhitelisted = await paratii.eth.tcr.isWhitelisted('some-video-id') */ async isWhitelisted (videoId) { let contract = await this.getTcrContract() let isWhitelisted = await contract.methods.isWhitelisted(videoId).call() return isWhitelisted } /** * check whether a video started the application process or not yet. * @param {string} videoId univocal video identifier randomly generated * @return {boolean} true if video started the application process, false otherwise * @example let appWasMade = await paratii.eth.tcr.didVideoApply('some-video-id') */ async didVideoApply (videoId) { let contract = await this.getTcrContract() let appWasMade = await contract.methods.appWasMade(videoId).call() return appWasMade } /** * start the application process.&lt;br&gt; * NOTE that this require the client approves PTI amount first before actually * running this function, use checkEligiblityAndApply instead. * @param {string} videoId univocal video identifier randomly generated * @param {Float} amountToStake number of tokens to stake. must &gt;= minDeposit * @return {boolean} returns true if all is good, plus _Application * event. * @example let result = await paratii.eth.tcr.apply('some-video-id', 'amount of tokens') */ async apply (videoId, amountToStake) { // FIXME: it is more efficient if we first call &quot;apply&quot;, and check for preconditions only after this failed let minDeposit = await this.getMinDeposit() if (this.eth.web3.utils.toBN(amountToStake).lt(minDeposit)) { throw new Error(`amount to stake ${amountToStake} is less than minDeposit ${minDeposit.toString()}`) } let contract = await this.getTcrContract() // let amountInWei = this.eth.web3.utils.toWei(amountToStake.toString()) let amountInHex = this.eth.web3.utils.toHex(amountToStake.toString()) // console.log('amountInHex: ', amountInHex) let tx try { tx = await contract.methods.apply(videoId, amountInHex).send() } catch (error) { throw error } // console.log('tx: ', tx) let vId try { vId = getInfoFromLogs(tx, '_Application', 'videoId', 1) } catch (e) { // FIXME: thsi error should be thrown if (e) { console.log(tx) // throw (e) // return false } } // console.log('vId: ', vId) if (vId) { return true } else { return false } } /** * Stake amountToStake on video with id videoId * does a number of separate steps: * - check preconditions for staking * - approve that the TCR contract can transfer amountToStake tokens * - apply to the TCR * @param {string} videoId univocal video identifier randomly generated * @param {number} amountToStake number of tokens to stake * @return {Promise} returns true if all is good, plus _Application * event. * @example let result = await paratii.eth.tcr.checkEligiblityAndApply('some-video-id', 'amount of tokens') */ // FIXME: better naming async checkEligiblityAndApply (videoId, amountToStake) { let minDeposit = await this.getMinDeposit() if (this.eth.web3.utils.toBN(amountToStake).lt(minDeposit)) { throw new Error(`amount to stake ${amountToStake} is less than minDeposit ${minDeposit.toString()}`) } // check if the videoId was already applied or is whitelisted let isWhitelisted = await this.isWhitelisted(videoId) if (isWhitelisted) { throw new Error(`video ${videoId} is already whitelisted`) } let appWasMade = await this.didVideoApply(videoId) if (appWasMade) { throw new Error(`video ${videoId} already applied and awaiting decision`) } // get some tokens let token = await this.eth.getContract('ParatiiToken') let tcrPlaceholder = await this.eth.getContract('TcrPlaceholder') // FIXME: restore this logic (it is broken!) // let balance = await token.methods.balanceOf(this.getAccount()).call() // if (this.eth.web3.utils.toBN(balance.toString()).lt(amountToStake)) { // throw new Error(`Your balance is to low: it is ${balance.toString()}, while a minimal deposit of ${minDeposit.toString()} is required`) // } let tx2 = await token.methods.approve(tcrPlaceholder.options.address, amountToStake).send() if (!tx2) { throw new Error('checkEligiblityAndApply Error ', tx2) } let allowance = await token.methods.allowance(this.eth.getAccount(), tcrPlaceholder.options.address).call() if (allowance.toString() !== amountToStake.toString()) { console.warn(`allowance ${allowance.toString()} != ${amountToStake.toString()}`) } let result = await this.apply(videoId, amountToStake) return result } /** * remove the video given by videoId from the listing * @param videoId univocal video identifier randomly generated * @return information about the transaction * @example let tx = await paratii.eth.tcr.exit('some-video-id') */ async exit (videoId) { let contract = await this.getTcrContract() return contract.methods.exit(videoId).send() } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.eth.users.js.html":{"id":"paratii.eth.users.js.html","title":"Source: paratii.eth.users.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.eth.users.js const joi = require('joi') /** * The eth.user namespace contains functions to interact with the video registration on the blockchain. * @param {Object} context ParatiiEth instance * @property {ParatiiEth} eth ParatiiEth instance */ export class ParatiiEthUsers { constructor (context) { // context is a ParatiiEth instance this.eth = context } /** * Get the contract instance of the user contract * @return {Promise} Object representing the contract */ async getRegistry () { return this.eth.getContract('Users') } /** * Creates a user * @param {Object} options information about the user * @param {string} options.id valid address * @param {string} options.name name of the user * @param {string} options.email email of the user * @param {string} options.ipfsData ipfs hash * @return {Promise} the id of the newly created user * @example let userData = { * id: 'some-id', * name: 'Humbert Humbert', * email: 'humbert@humbert.ru', * ipfsData: 'some-hash' * } * let result = await paratii.eth.users.create(userData) */ async create (options) { const schema = joi.object({ id: joi.string(), name: joi.string(), email: joi.string(), ipfsData: joi.string() }) if (!this.eth.web3.utils.isAddress(options.id)) { let msg = `The &quot;id&quot; argument should be a valid address, not ${options.id}` throw Error(msg) } const result = joi.validate(options, schema) const error = result.error if (error) throw error options = result.value let contract = await this.getRegistry() await contract.methods.create(options.id, options.name, options.email, options.ipfsData).send() return options.id } /** * Get a users details from the blockchain * @param {string} userId valid address * @return {Promise} information about the user * @example user = await paratii.eth.users.get('some-id') */ async get (userId) { let contract = await this.getRegistry() let userInfo = await contract.methods.get(userId).call() let result = { id: userId, name: userInfo[0], email: userInfo[1], ipfsData: userInfo[2] } return result } /** * Updates a user details on the blockchain. * @param {string} userId valid address * @param {Object} options information to update. Left-out data is kept the same. * @return {Promise} updated data * @example await paratii.eth.users.update('some-id', {ipfsData: 'new-hash'}) */ async update (userId, options) { options.id = userId let data = await this.get(userId) for (let key in options) { data[key] = options[key] } await this.create(data) return data } /** * Deletes a user from the blockchain. Can only be called by the contract owner or the user him/her-self * @param {string} userId valid address * @return {Promise} blockchain transaction * @example await paratii.eth.users.delete('some-id') */ async delete (userId) { let contract = await this.getRegistry() let tx = contract.methods.remove(userId).send() return tx } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.eth.vids.js.html":{"id":"paratii.eth.vids.js.html","title":"Source: paratii.eth.vids.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.eth.vids.js import { getInfoFromLogs, makeId, NULL_ADDRESS } from './utils.js' const joi = require('joi') /** * The eth.vids namespace contains functions to interact with the video registration on the blockchain. * @param {Object} context ParatiiEth instance * @property {ParatiiEth} eth ParatiiEth instance */ export class ParatiiEthVids { constructor (context) { // context is a ParatiiEth instance this.eth = context } /** * Get the contract instance of the videos contract * @return {Promise} Object representing the contract * @example let contract = await paratii.eth.vids.getVideoRegistry() */ async getVideoRegistry () { let contract = await this.eth.getContract('Videos') if (contract.options.address === '0x0') { throw Error('There is not Videos contract known in the registry') } return contract } /** * Get the contract instance of the likes contract * @return {Promise} Object representing the contract * @example let contract = await paratii.eth.vids.getLikesContract() */ async getLikesContract () { let contract = await this.eth.getContract('Likes') if (contract.options.address === '0x0') { throw Error('There is not Likes contract known in the registry') } return contract } /** * Get the contract instance of the views contract * @return {Promise} Object representing the contract * @example let contract = await paratii.eth.vids.getViewsContract() */ async getViewsContract () { let contract = await this.eth.getContract('Views') if (contract.options.address === '0x0') { throw Error('There is not Views contract known in the registry') } return contract } /** * Creates a random id * @return {string} id created * @example let id = paratii.eth.vids.makeId() */ makeId () { // create a fresh ID return makeId() } /** * Record the video on the blockchain * @param {Object} options data about the video * @param {number} [retry=1] optional, default = 1 * @return {Promise} the video id * @example let videoId = await paratii.eth.vids.create({ * id: 'some-id', * price: 20, * owner: 'some-address', * ipfsHash: 'some-hash' * }) */ async create (options, retry = 1) { const schema = joi.object({ id: joi.string(), owner: joi.string().required(), price: joi.any().default(0), ipfsHashOrig: joi.string().empty('').default(''), ipfsHash: joi.string().empty('').default(''), ipfsData: joi.string().default('') }) const result = joi.validate(options, schema) if (result.error) { throw result.error } const validatedOptions = result.value if (!validatedOptions.id) { validatedOptions.id = this.makeId() } if (!this.eth.web3.utils.isAddress(validatedOptions.owner)) { let msg = `The owner argument should be a valid address, not ${validatedOptions.owner}` throw Error(msg) } let contract = await this.getVideoRegistry() try { let tx = await contract.methods.create( validatedOptions.id, validatedOptions.owner, validatedOptions.price, validatedOptions.ipfsHashOrig, validatedOptions.ipfsHash, validatedOptions.ipfsData ).send() let videoId = getInfoFromLogs(tx, 'LogCreateVideo', 'videoId') return videoId } catch (err) { if (/Transaction nonce is too low./.exec(err.message) &amp;&amp; retry &gt; 0) { return this.create(options, retry - 1) } if (/There is another transaction with same nonce in the queue./.exec(err.message) &amp;&amp; retry &gt; 0) { return this.create(options, retry - 1) } if (/Transaction with the same hash was already imported./.exec(err.message)) { // this means that there is no need to send this transaction again return validatedOptions.id } throw err } } /** * get data about the video * @param {string} videoId univocal video id * @return {Promise} data about the video * @example let video = eth.vids.get('0x12345') */ async get (videoId) { let contract = await this.getVideoRegistry() let videoInfo = await contract.methods.get(videoId).call() let result = { id: videoId, owner: videoInfo[0], price: videoInfo[1], ipfsHashOrig: videoInfo[2], ipfsHash: videoInfo[3], ipfsData: videoInfo[4] } if (result.owner === NULL_ADDRESS) { throw Error(`No video with id '${videoId}' was registered`) } return result } /** * record a like/dislike to the video on the blockchain * TODO RIVEDI I TIPI * @param {Object} options data about the video to like * @param {string} options.videoId univocal video id * @param {Boolean} options.liked true/false * @return {Promise} transaction recording the like * @example await paratii.eth.vids.sendLike({ videoId: 'some-id', liked: true }) * @example await paratii.eth.vids.sendLike({ videoId: 'some-id', liked: false }) */ async sendLike (options) { const schema = joi.object({ videoId: joi.string().required(), liked: joi.bool().required() }) const result = joi.validate(options, schema) const error = result.error if (error) throw error options = result.value if (options.liked !== true &amp;&amp; options.liked !== false) { let msg = 'The liked argument should be a boolean' throw Error(msg) } let contract = await this.getVideoRegistry() let contract2 = await this.getLikesContract() let videoInfo = await contract.methods.get(options.videoId).call() if (videoInfo[0] === NULL_ADDRESS) { let msg = `Video with ID '${options.videoId}' doesn't exist` throw Error(msg) } let tx = await contract2.methods.likeVideo( options.videoId, options.liked ).send() return tx } /** * record a views to the video on the blockchain * @param {Object} options data about the video and the viewer * @param {string} options.viewer address of the viewer * @param {string} options.videoId univocal video identifier randomly generated * @param {string} options.ipfsData ipfs multihash * @return {Promise} transaction recording the view * @example await paratii.eth.vids.view({viewer:'some-user-id',videoId: 'some-video-id'}) */ async view (options) { const schema = joi.object({ viewer: joi.string().required(), videoId: joi.string().required(), ipfsData: joi.string().default(null) }) const result = joi.validate(options, schema) const error = result.error if (error) throw error options = result.value let contract = await this.getViewsContract() let tx = await contract.methods.create( options.viewer, options.videoId, options.ipfsData ).send() return tx } /** * Check if the viewer has already viewed the video * @param {Object} options data about the video and the viewer * @param {string} options.viewer viewer address * @param {string} options.videoId univocal video identifier * @return {Promise} true if the current user already viewed the video, false otherwise * @example let result = await paratii.eth.vids.userViewedVideo({viewer:'some-user-id',videoId: 'some-video-id'}) */ async userViewedVideo (options) { const schema = joi.object({ viewer: joi.string().required(), videoId: joi.string().required() }) const result = joi.validate(options, schema) const error = result.error if (error) throw error options = result.value let contract = await this.getViewsContract() return contract.methods.userViewedVideo( options.viewer, options.videoId ).call() } /** * Writes a like for the video on the blockchain (contract Likes), and negates a dislike for the video, if it exists. * @param {string} videoId univocal video identifier randomly generated * @return {Promise} transaction recording the like * @example let result = paratii.eth.vids.like('some-id') */ async like (videoId) { await this.sendLike({ videoId: videoId, liked: true }) } /** * Writes a dislike for the video on the blockchain (contract Likes), and negates a like for the video, if it exists. * @param {string} videoId univocal video identifier randomly generated * @return {Promise} transaction recording the dislike * @example let result = paratii.eth.vids.dislike('some-id') */ async dislike (videoId) { await this.sendLike({ videoId: videoId, liked: false }) } /** * Check if the current user has already liked the video * @param {string} videoId univocal video identifier randomly generated * @return {Promise} true if the current user already liked the video, false otherwise * @example let result = paratii.eth.vids.doesLike('some-id') */ async doesLike (videoId) { let contract = await this.getLikesContract() let address = this.eth.getAccount() let likeInfo = await contract.methods.userLikesVideo(address, videoId).call() return likeInfo } /** * Check if the current user has already disliked the video. * @param {string} videoId univocal video identifier randomly generated * @return {Promise} true if the current user already disliked the video, false otherwise * @example let result = paratii.eth.vids.doesDislike('some-id') */ async doesDislike (videoId) { let contract = await this.getLikesContract() let address = this.eth.getAccount() let likeInfo = await contract.methods.userDislikesVideo(address, videoId).call() return likeInfo } /** * Update the information on the video. * Only the account that has registered the video, or the owner of the contract, can update the information. * @param {string} videoId univocal video identifier * @param {Object} options key value pairs of properties and new values e.g. ({title: 'another-title'}) * @return {Promise} Updated video informations * @example paratii.eth.vids.update('some-video-id', {title: 'another-title'}) */ async update (videoId, options) { options.id = videoId let data = await this.get(videoId) for (let key in options) { data[key] = options[key] } await this.create(data, 'updating') return data } /** * delete the video from the blockchain * @param {string} videoId univocal video identifier randomly generated * @return {Promise} transaction recording the remove action * @example let tx = paratii.eth.vids.delete('some-id') */ async delete (videoId) { let contract = await this.getVideoRegistry() // contract.setProvider(this.eth.config.provider) let tx = await contract.methods.remove(videoId).send() return tx } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.eth.vouchers.js.html":{"id":"paratii.eth.vouchers.js.html","title":"Source: paratii.eth.vouchers.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.eth.vouchers.js import { getInfoFromLogs, NULL_ADDRESS, makeId } from './utils.js' const joi = require('joi') /** * Functions for redeeming vouchers * @param {Object} context ParatiiEth instance * @property {ParatiiEth} eth ParatiiEth instance */ export class ParatiiEthVouchers { constructor (context) { // context is a ParatiiEth instance this.eth = context } /** * Get the contract instance of the vouchers contract * @return {Promise} Object representing the contract * @example let contract = await paratii.eth.vids.getVouchersContract() */ async getVouchersContract () { let contract = await this.eth.getContract('Vouchers') if (contract.options.address === '0x0') { throw Error('There is not Vouchers contract known in the registry') } return contract } /** * Function for creating a voucher. Can only be called by the owner of the contract. * @param {Object} options data about the voucher * @param {string} options.voucherCode unique string associated to this voucher * @param {number} options.amount amount of PTI in wei of this voucher * @return {Promise} the voucher id * @example await paratii.eth.vouchers.create({ voucherCode: 'some-id', amount: 10 }) */ async create (options) { const schema = joi.object({ voucherCode: joi.string(), amount: joi.number() }) const result = joi.validate(options, schema) const error = result.error if (error) throw error options = result.value if (options.voucherCode === null) { let msg = 'Voucher Code argument must not be null' throw Error(msg) } if (typeof options.voucherCode !== 'string') { let msg = 'Voucher Code argument needs to be a string' throw Error(msg) } if (typeof options.amount !== 'number') { let msg = 'Amount argument needs to be a number' throw Error(msg) } if (options.amount === 0) { let msg = 'Amount needs to be greater than zero' throw Error(msg) } let contract = await this.getVouchersContract() let hashedVoucher = await contract.methods.hashVoucher(options.voucherCode).call() let tx = await contract.methods.create( hashedVoucher, options.amount ).send() let voucherId = getInfoFromLogs(tx, 'LogCreateVoucher', '_hashedVoucher') return voucherId } /** * throws a test error */ async test () { throw Error('test error message') } /** * Generates a given number of vouchers with unique IDs, and the given amount, and returns an array of objects. * @param {number} number number of voucher to create * @param {number} amount amount of every voucher * @return {Promise} Object containing every voucher created * @example let vouchers = await paratii.eth.vouchers.createVouchers(10, 10) */ async createVouchers (number, amount) { let i let vouchers = [] for (i = 0; i &lt; number; i++) { let code = makeId() let voucher = { voucherCode: code, amount: amount } await this.create(voucher) vouchers.push(voucher) } return vouchers } /** * Function for redeeming a voucher to the current account's address. * @param {string} voucherCode univocal voucher code * @return {Promise} true if everything goes well, otherwise throws an error * @example await paratii.eth.vouchers.redeem('some-code') */ async redeem (voucherCode) { let contract = await this.getVouchersContract() let voucherBytes = await contract.methods.hashVoucher(voucherCode).call() let thisVoucher = await contract.methods.vouchers(voucherBytes).call() let thisVoucherClaimant = thisVoucher[0].toString() let thisVoucherAmount = Number(thisVoucher[1]) let vouchersContractBalance = Number(await this.eth.balanceOf(contract.options.address, 'PTI')) if (thisVoucherClaimant !== NULL_ADDRESS) { throw Error('This voucher was already used') } if (thisVoucherAmount &gt; vouchersContractBalance) { throw Error('The Vouchers contract doesn\\'t have enough PTI to redeem the voucher') } if (thisVoucherAmount === Number(0)) { throw Error('This voucher doesn\\'t exist') } try { let tx = await contract.methods.redeem(voucherCode).send() let claimant = getInfoFromLogs(tx, 'LogRedeemVoucher', '_claimant', 1) let amount = getInfoFromLogs(tx, 'LogRedeemVoucher', '_amount', 1) if (claimant === this.eth.getAccount()) { return amount } else { return false } } catch (e) { throw Error('An unknown error occurred') } } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.ipfs.js.html":{"id":"paratii.ipfs.js.html","title":"Source: paratii.ipfs.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.ipfs.js /* global ArrayBuffer */ import Protocol from 'paratii-protocol' import { ipfsSchema, accountSchema } from './schemas.js' import joi from 'joi' import { EventEmitter } from 'events' import { ParatiiIPFSRemote } from './paratii.ipfs.remote.js' import { ParatiiIPFSLocal } from './paratii.ipfs.local.js' import { ParatiiTranscoder } from './paratii.transcoder.js' import { PromiseEventEmitter } from './utils.js' global.Buffer = global.Buffer || require('buffer').Buffer /** * Contains functions to interact with the IPFS instance * @param {ParatiiIPFSSchema} config configuration object to initialize Paratii object * @property {ParatiiIPFSLocal} local operations on the local node * @property {ParatiiIPFSRemote} remote operations on remote node */ export class ParatiiIPFS extends EventEmitter { /** * @typedef {Array} ParatiiIPFSSchema * @property {?ipfsSchema} ipfs * @property {?accountSchema} account * @property {?boolean} verbose */ constructor (config) { super() const schema = joi.object({ ipfs: ipfsSchema, account: accountSchema, verbose: joi.bool().default(true) }) const result = joi.validate(config, schema, {allowUnknown: true}) if (result.error) throw result.error this.config = config this.config.ipfs = result.value.ipfs this.config.account = result.value.account this.config.ipfsInstance = this this.local = new ParatiiIPFSLocal(config) this.remote = new ParatiiIPFSRemote({ipfs: this.config.ipfs, paratiiIPFS: this}) this.transcoder = new ParatiiTranscoder({ipfs: this.config.ipfs, paratiiIPFS: this}) } // /** // * adds a data Object to the IPFS local instance // * @param {Object} data JSON object to store // * @return {Promise} promise with the ipfs multihash // * @example let result = await paratiiIPFS.local.addJSON(data) // */ // async addJSON (data) { // let ipfs = await this.getIPFSInstance() // // if (!this.ipfs || !this.ipfs.isOnline()) { // // throw new Error('IPFS node is not ready, please trigger getIPFSInstance first') // // } // const obj = { // Data: Buffer.from(JSON.stringify(data)), // Links: [] // } // let node // try { // // node = await ipfs.object.put(obj) // node = await ipfs.files.add(obj.Data) // } catch (e) { // if (e) throw e // } // // return node[0].hash // } /** * Starts the IPFS node * @return {Promise} that resolves in an IPFS instance * @example paratii.ipfs.start() */ start () { return new Promise((resolve, reject) =&gt; { if (this.ipfs &amp;&amp; this.ipfs.isOnline()) { console.log('IPFS is already running') return resolve(this.ipfs) } this.getIPFSInstance().then(function (ipfs) { resolve(ipfs) }) }) } /** * Stops the IPFS node. * @example paratii.ipfs.stop() */ stop () { return new Promise((resolve, reject) =&gt; { if (!this.ipfs || !this.ipfs.isOnline()) { resolve() } if (this.ipfs) { this.ipfs.stop(() =&gt; { setImmediate(() =&gt; { resolve() }) }) } }) } _getAccount () { return (this.config.paratii &amp;&amp; this.config.paratii.eth.getAccount()) || 'unknown' } /** * adds a JSON structure to the local node and signals remote node to pin it * @param {object} data JSON object to store * @return {string} returns ipfs multihash of the stored object. * @example let result = await paratiiIPFS.addAndPinJSON(data) */ async addAndPinJSON (data) { return new PromiseEventEmitter(async (resolve, reject) =&gt; { let hash = await this.local.addJSON(data) let pinFile = () =&gt; { let pinEv = this.remote.pinFile(hash, { author: this._getAccount() } ) pinEv.on('pin:error', (err) =&gt; { console.warn('pin:error:', hash, ' : ', err) pinEv.removeAllListeners() }) pinEv.on('pin:done', (hash) =&gt; { this.log('pin:done:', hash) pinEv.removeAllListeners() }) return pinEv } let pinEv = pinFile() pinEv.on('pin:error', (err) =&gt; { console.warn('pin:error:', hash, ' : ', err) console.log('trying again') pinEv = pinFile() }) pinEv.on('pin:done', (hash) =&gt; { resolve(hash) }) }) } /** * log messages on the console if verbose is set * @param {string} msg text to log * @example * paratii.ipfs.log(&quot;some-text&quot;) */ log (...msg) { if (this.config.verbose) { console.log(...msg) } } /** * log warns on the console if verbose is set * @param {string} msg warn text * @example * paratii.ipfs.warn(&quot;some-text&quot;) */ warn (...msg) { if (this.config.verbose) { console.warn(...msg) } } /** * log errors on the console if verbose is set * @param {string} msg error message * @example * paratii.ipfs.error(&quot;some-text&quot;) */ error (...msg) { if (this.config.verbose) { console.error(...msg) } } /** * get an ipfs instance of jsipfs. Singleton pattern * @return {Object} Ipfs instance * @example ipfs = await paratii.ipfs.getIPFSInstance() * @private */ getIPFSInstance () { return new Promise((resolve, reject) =&gt; { if (this.ipfs) { resolve(this.ipfs) } else { let config = this.config // there will be no joi in IPFS (pun indended) import(/* webpackChunkName: 'ipfs' */ 'ipfs') // eslint-disable-line .then((Ipfs) =&gt; { let ipfs = new Ipfs({ bitswap: { // maxMessageSize: 256 * 1024 maxMessageSize: this.config.ipfs['bitswap.maxMessageSize'] }, start: true, repo: config.ipfs.repo || '/tmp/test-repo-' + String(Math.random()), config: { Addresses: { Swarm: this.config.ipfs.swarm // [ // '/dns4/star.paratii.video/tcp/443/wss/p2p-webrtc-star', // '/dns4/ws.star.paratii.video/tcp/443/wss/p2p-websocket-star/' // ] }, Bootstrap: this.config.ipfs.bootstrap // [ // '/dns4/bootstrap.paratii.video/tcp/443/wss/ipfs/QmeUmy6UtuEs91TH6bKnfuU1Yvp63CkZJWm624MjBEBazW' // ] } }) this.ipfs = ipfs ipfs.on('ready', () =&gt; { this.log('[IPFS] node Ready.') ipfs._bitswap.notifications.on('receivedNewBlock', (peerId, block) =&gt; { this.log('[IPFS] receivedNewBlock | peer: ', peerId.toB58String(), ' block length: ', block.data.length) this.log('---------[IPFS] bitswap LedgerMap ---------------------') ipfs._bitswap.engine.ledgerMap.forEach((ledger, peerId, ledgerMap) =&gt; { this.log(`${peerId} : ${JSON.stringify(ledger.accounting)}\\n`) }) this.log('-------------------------------------------------------') }) ipfs.id().then((id) =&gt; { let peerInfo = id this.id = id this.log(`[IPFS] id: ${peerInfo}`) let ptiAddress = this.config.account.address || 'no_address' this.protocol = new Protocol( ipfs._libp2pNode, ipfs._repo.blocks, // add ETH Address here. ptiAddress ) this._node = ipfs this.remote._node = ipfs this.protocol.notifications.on('message:new', (peerId, msg) =&gt; { this.log('[paratii-protocol] ', peerId.toB58String(), ' new Msg: ', msg) }) // emit all commands. // NOTE : this will be changed once protocol upgrades are ready. this.protocol.notifications.on('command', (peerId, command) =&gt; { this.emit('protocol:incoming', peerId, command) }) this.ipfs = ipfs this.protocol.start(() =&gt; { setTimeout(() =&gt; { resolve(ipfs) }, 10) }) }) }) ipfs.on('error', (err) =&gt; { if (err) { // this.log('IPFS node ', ipfs) this.error('[IPFS] Error ', err) reject(err) } }) }) } }) } /** * adds a file to local IPFS node and signals transcoder to transcode it * @param {Array} files Array of HTML5 File Objects * @returns An EventEmitter */ addAndTranscode (files) { let ev = this.local.add(files) ev.on('done', (files) =&gt; { this.config.paratii.transcoder._signalTranscoder(files, ev) }) return ev } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.ipfs.local.js.html":{"id":"paratii.ipfs.local.js.html","title":"Source: paratii.ipfs.local.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.ipfs.local.js /* global File, ArrayBuffer */ 'use strict' import { EventEmitter } from 'events' import { PromiseEventEmitter } from './utils.js' const pull = require('pull-stream') const pullFilereader = require('pull-filereader') const toPull = require('stream-to-pull-stream') const fs = require('fs') const path = require('path') const { eachSeries, nextTick } = require('async') const once = require('once') /** * IPFS UPLOADER : Paratii IPFS uploader interface. * @extends EventEmitter * @param {ParatiiIPFSUploaderSchema} opts */ export class ParatiiIPFSLocal extends EventEmitter { /** * @typedef {Array} ParatiiIPFSUploaderSchema * @property {?ipfsSchema} ipfs * @property {?Object} ParatiiIPFS */ constructor (config) { super() // const schema = joi.object({ // ipfs: ipfsSchema, // paratiiIPFS: joi.object().optional() // // onReadyHook: joi.array().ordered().default([]), // // protocol: joi.string().default(null), // }) // const result = joi.validate(opts, schema, {allowUnknown: true}) // if (result.error) throw result.error // this.config = result.value this.config = config this._ipfs = this.config.ipfsInstance } /** * uploads a single file to *local* IPFS node * @param {File} file HTML5 File Object. * @returns {EventEmitter} checkout the upload function below for details. * @example let uploaderEv = paratiiIPFS.uploader.add(files) */ add (file) { const p = new PromiseEventEmitter((resolve, reject) =&gt; { // return new Promise((resolve, reject) =&gt; { let files if (Array.isArray(file)) { files = file } else { files = [file] } let result = [] for (let i = 0; i &lt; files.length; i++) { // check if File is actually available or not. // if not it means we're not in the browser land. if (typeof File !== 'undefined') { if (files[i] instanceof File) { result.push(this.html5FileToPull(files[i])) } else { result.push(this.fsFileToPull(files[i])) } } else { result.push(this.fsFileToPull(files[i])) } } const ev = this.upload(result, this) ev.on('done', (hashedFiles) =&gt; resolve(hashedFiles)) ev.on('error', (err) =&gt; reject(err)) }) return p } /** * upload an Array of files as is to the local IPFS node * @param {Array} files HTML5 File Object Array. * @return {EventEmitter} returns EventEmitter with the following events: * - 'start': uploader started. * - 'progress': (chunkLength, progressPercent) * - 'fileReady': (file) triggered when a file is uploaded locally. * - 'done': (files) triggered when the uploader is done locally. * - 'error': (err) triggered whenever an error occurs. * @example paratii.ipfs.local.upload('path/to/file') * TODO: this is not &quot;local&quot; only, it calls xhrupload in case we are dealing with an html5 file! */ upload (files, ev) { let meta = {} // holds File metadata. if (!ev) { ev = new EventEmitter() } this._ipfs.start().then(() =&gt; { // trigger onStart callback ev.emit('start') if (files &amp;&amp; files[0] &amp;&amp; files[0].size &gt; this.config.ipfs.maxFileSize) { ev.emit('error', `file size is larger than the allowed ${this.config.ipfs.maxFileSize / 1024 / 1024}MB`) return } pull( pull.values(files), pull.through((file) =&gt; { this._ipfs.log('Adding ', file) meta.fileSize = file.size meta.total = 0 }), pull.asyncMap((file, cb) =&gt; pull( pull.values([{ path: file.name, content: pull( file._pullStream, pull.through((chunk) =&gt; ev.emit('progress2', chunk.length, Math.floor((meta.total += chunk.length) * 1.0 / meta.fileSize * 100))) ) }]), this._ipfs._node.files.addPullStream({chunkerOptions: {maxChunkSize: this.config.ipfs.chunkSize}}), // default size 262144 pull.collect((err, res) =&gt; { if (err) { return ev.emit('error', err) } const hashedFile = res[0] this._ipfs.log('Adding %s finished as %s, size: %s', hashedFile.path, hashedFile.hash, hashedFile.size) if (file._html5File) { this.remote.xhrUpload(file, hashedFile.hash, ev) } else { ev.emit('fileReady', hashedFile) } cb(null, hashedFile) }) )), pull.collect((err, hashedFiles) =&gt; { if (err) { ev.emit('error', err) } this._ipfs.log('uploader is DONE') ev.emit('done', hashedFiles) }) ) }) return ev } /** * upload an entire directory to IPFS * @param {string} dirPath path to directory * @return {Promise} returns the {multihash, path, size} for the uploaded folder. * @example ? */ addDirectory (dirPath) { return new Promise((resolve, reject) =&gt; { // cb = once(cb) let resp = null // this._ipfs.log('adding ', dirPath, ' to IPFS') const addStream = this._ipfs._node.files.addReadableStream() addStream.on('data', (file) =&gt; { // this._ipfs.log('dirPath ', dirPath) // this._ipfs.log('file Added ', file) if (file.path === dirPath) { // this._ipfs.log('this is the hash to return ') resp = file nextTick(() =&gt; resolve(resp)) } }) addStream.on('end', () =&gt; { // this._ipfs.log('addStream ended') // nextTick(() =&gt; cb(null, resp)) }) fs.readdir(dirPath, (err, files) =&gt; { if (err) return reject(err) eachSeries(files, (file, next) =&gt; { next = once(next) try { this._ipfs.log('reading file ', file) let rStream = fs.createReadStream(path.join(dirPath, file)) rStream.on('error', (err) =&gt; { if (err) { this._ipfs.error('rStream Error ', err) return next() } }) if (rStream) { addStream.write({ path: path.join(dirPath, file), content: rStream }) } } catch (e) { if (e) { this._ipfs.error('createReadStream Error: ', e) } } finally { } // next() nextTick(() =&gt; next()) }, (err) =&gt; { if (err) return reject(err) // addStream.destroy() addStream.end() }) }) }) } /** * get file from ipfs * @param {string} hash ipfs multihash of the file * @return {Promise} the file (path,content) * @example * let result = await paratiiIPFS.add(fileStream) * let hash = result[0].hash * let fileContent = await paratiiIPFS.get(hash) */ async get (hash) { let ipfs = await this._ipfs.getIPFSInstance() return ipfs.files.get(hash) } /** * gets a JSON object stored in IPFS * @param {string} multihash ipfs multihash of the object * @return {Promise} requested Object * @example let jsonObj = await paratii.ipfs.getJSON('some-multihash') */ async getJSON (multihash) { let ipfs = await this._ipfs.getIPFSInstance() let node try { node = await ipfs.files.cat(multihash) } catch (e) { if (e) throw e } return JSON.parse(node.toString()) } /** * adds a data Object to the IPFS local instance * @param {Object} data JSON object to store * @return {Promise} promise that resolves as the ipfs multihash * @example let result = await paratii.ipfs.local.addJSON(data) */ async addJSON (data) { let ipfs = await this._ipfs.getIPFSInstance() const obj = { Data: Buffer.from(JSON.stringify(data)), Links: [] } let node try { // node = await ipfs.object.put(obj) node = await ipfs.files.add(obj.Data) } catch (e) { if (e) throw e } return node[0].hash } /** * returns a generic File Object with a Pull Stream from an HTML5 File * @param {File} file HTML5 File Object * @return {Object} generic file object. * @example ? * @private */ html5FileToPull (file) { return { name: file.name, size: file.size, path: file.path, _html5File: file, _pullStream: pullFilereader(file) } } /** * returns a generic file Object from a file path * @param {string} filePath Path to file. * @return {Object} generic file object. * @example ? * @private */ fsFileToPull (filePath) { let stats = fs.statSync(filePath) if (stats) { return { name: path.basename(filePath), size: stats.size, _pullStream: toPull(fs.createReadStream(filePath)) } } else { return null } } /** * log messages on the console if verbose is set * @param {string} msg text to log * @example * paratii.ipfs.log(&quot;some-text&quot;) * @private */ log (...msg) { if (this.config.verbose) { console.log(...msg) } } /** * log warns on the console if verbose is set * @param {string} msg warn text * @example * paratii.ipfs.warn(&quot;some-text&quot;) * @private */ warn (...msg) { if (this.config.verbose) { console.warn(...msg) } } /** * log errors on the console if verbose is set * @param {string} msg error message * @example * paratii.ipfs.error(&quot;some-text&quot;) * @private */ error (...msg) { if (this.config.verbose) { console.error(...msg) } } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.ipfs.remote.js.html":{"id":"paratii.ipfs.remote.js.html","title":"Source: paratii.ipfs.remote.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.ipfs.remote.js /* global ArrayBuffer */ 'use strict' import { ipfsSchema } from './schemas.js' import { EventEmitter } from 'events' import joi from 'joi' const Resumable = require('resumablejs') const Multiaddr = require('multiaddr') /** * IPFS UPLOADER : Paratii IPFS uploader interface. * @extends EventEmitter * @param {ParatiiIPFSUploaderSchema} opts */ export class ParatiiIPFSRemote extends EventEmitter { /** * @typedef {Array} ParatiiIPFSUploaderSchema * @property {?ipfsSchema} ipfs * @property {?Object} ParatiiIPFS */ constructor (opts) { super() const schema = joi.object({ ipfs: ipfsSchema, paratiiIPFS: joi.object().optional() // onReadyHook: joi.array().ordered().default([]), // protocol: joi.string().default(null), }) const result = joi.validate(opts, schema, {allowUnknown: true}) if (result.error) throw result.error this.config = result.value this._ipfs = this.config.paratiiIPFS // this is the paratii.ipfs.js } /** * Upload a file over XHR to the transcoder. To be called with an event emitter as the last argument * @param {Object} file file to upload * @param {string} hash IPFS multi-hash of the file * @param {?EventEmitter} ev optional event emitter * @example this.xhrUpload(file, hashedFile) */ xhrUpload (file, hash, ev) { if (!ev) { ev = new EventEmitter() } let r = new Resumable({ target: `${this.config.ipfs.transcoderDropUrl}/${hash}`, chunkSize: this.config.ipfs.xhrChunkSize, simultaneousUploads: 4, testChunks: false, throttleProgressCallbacks: 1, maxFileSize: this.config.ipfs.maxFileSize }) r.on('fileAdded', (file, ev) =&gt; { console.log('file ', file, 'added') }) r.on('fileProgress', (file) =&gt; { ev.emit('progress', r.progress() * 100) }) r.on('complete', () =&gt; { ev.emit('fileReady', file) }) r.on('error', (err, file) =&gt; { console.error('file ', file, 'err ', err) }) r.addFile(file._html5File) setTimeout(() =&gt; { r.upload() }, 1) } /** * [getMetaData description] * @param {Object} fileHash [description] * @param {Object} options [description] * @return {Object} [description] * @private */ getMetaData (fileHash, options) { return new Promise((resolve, reject) =&gt; { const schema = joi.object({ transcoder: joi.string().default(this.config.ipfs.defaultTranscoder), transcoderId: joi.any().default(Multiaddr(this.config.ipfs.defaultTranscoder).getPeerId()) }).unknown() this._ipfs.log('Signaling transcoder getMetaData...') const result = joi.validate(options, schema) const error = result.error if (error) reject(error) let opts = result.value console.log('opts: ', opts) let ev if (opts.ev) { ev = opts.ev } else { ev = new EventEmitter() } this._ipfs.start().then(() =&gt; { let msg = this._ipfs.protocol.createCommand('getMetaData', {hash: fileHash}) // FIXME : This is for dev, so we just signal our transcoder node. // This needs to be dynamic later on. this._ipfs.ipfs.swarm.connect(opts.transcoder, (err, success) =&gt; { if (err) return reject(err) opts.transcoderId = opts.transcoderId || Multiaddr(opts.transcoder).getPeerId() this._ipfs.log('transcoderId: ', opts.transcoderId) this._node.swarm.peers((err, peers) =&gt; { this._ipfs.log('peers: ', peers) if (err) return reject(err) peers.map((peer) =&gt; { this._ipfs.log('peerID : ', peer.peer.id.toB58String(), opts.transcoderId, peer.peer.id.toB58String() === opts.transcoder) if (peer.peer.id.toB58String() === opts.transcoderId) { this._ipfs.log(`sending getMetaData msg to ${peer.peer.id.toB58String()} with request to transcode ${fileHash}`) this._ipfs.protocol.network.sendMessage(peer.peer.id, msg, (err) =&gt; { if (err) { ev.emit('getMetaData:error', err) return ev } }) } }) // paratii getMetaData signal. this._ipfs.on('protocol:incoming', (peerId, command) =&gt; { this._ipfs.log('paratii protocol: Received command ', command.payload.toString(), 'args: ', command.args.toString()) let commandStr = command.payload.toString() let argsObj try { argsObj = JSON.parse(command.args.toString()) } catch (e) { this._ipfs.error('couldn\\'t parse args, ', command.args.toString()) } switch (commandStr) { case 'getMetaData:error': if (argsObj.hash === fileHash) { console.log('DEBUG getMetaData ERROR: fileHash: ', fileHash, ' , errHash: ', argsObj.hash) reject(argsObj.err) } break case 'getMetaData:done': if (argsObj.hash === fileHash) { console.log('data: ', argsObj.data) let result = argsObj.data resolve(result) } break default: this._ipfs.log('unknown command : ', commandStr) } }) }) }) }) }) } /** * Signal the remote node to pin a File * @param {Object} fileHash hash of the file to pin * @param {Object} options [description] * @return {Promise} a Promise/EventEmitter that resolves inthe hash of the pinned file * @example paratii.ipfs.remote.pinFile('QmQP5SJzEBKy1uAGASDfEPqeFJ3HUbEp4eZzxvTLdZZYwB') */ pinFile (fileHash, options) { if (options === undefined) { options = {} } const schema = joi.object({ author: joi.string().default('0x'), // ETH/PTI address of the file owner transcoder: joi.string().default(this.config.ipfs.defaultTranscoder), transcoderId: joi.any().default(Multiaddr(this.config.ipfs.defaultTranscoder).getPeerId()), size: joi.number().default(0) }).unknown() this._ipfs.log(`Signaling transcoder to pin ${fileHash}`) const result = joi.validate(options, schema) const error = result.error if (error) throw error let opts = result.value let ev if (opts.ev) { ev = opts.ev } else { ev = new EventEmitter() } let msg = this._ipfs.protocol.createCommand('pin', {hash: fileHash, author: opts.author, size: opts.size}) // FIXME : This is for dev, so we just signal our transcoder node. // This needs to be dynamic later on. this._node.swarm.connect(opts.transcoder, (err, success) =&gt; { if (err) return ev.emit('pin:error', err) this._node.swarm.peers((err, peers) =&gt; { this._ipfs.log('peers: ', peers) if (err) return ev.emit('pin:error', err) peers.map((peer) =&gt; { try { this._ipfs.log('peer.peer.toB58String(): ', peer.peer.toB58String()) if (peer.peer.toB58String() === opts.transcoderId) { this._ipfs.log(`sending pin msg to ${peer.peer._idB58String} with request to pin ${fileHash}`) this._ipfs.protocol.network.sendMessage(peer.peer, msg, (err) =&gt; { if (err) { ev.emit('pin:error', err) console.log(err) return ev } }) } } catch (e) { console.log('PEER ERROR :', e, peer) } }) // paratii pinning response. this._ipfs.on('protocol:incoming', this._pinResponseHandler(ev)) }) }) return ev } /** * [_pinResponseHandler description] * @param {Object} ev [description] * @return {Object} [description] * @private */ _pinResponseHandler (ev) { return (peerId, command) =&gt; { this._ipfs.log('paratii protocol: Received command ', command.payload.toString(), 'args: ', command.args.toString()) let commandStr = command.payload.toString() let argsObj try { argsObj = JSON.parse(command.args.toString()) } catch (e) { this._ipfs.log('couldn\\'t parse args, ', command.args.toString()) } switch (commandStr) { case 'pin:error': ev.emit('pin:error', argsObj.err) break case 'pin:progress': ev.emit('pin:progress', argsObj.hash, argsObj.chunkSize, argsObj.percent) break case 'pin:done': ev.emit('pin:done', argsObj.hash) break default: this._ipfs.log('unknown command : ', commandStr) } } } // grabYt (url, onResponse, callback) { // let starttime // let fileSize // let video = ytdl(url) // video.once('response', () =&gt; { // this._ipfs.log(`starting ${url}`) // starttime = Date.now() // onResponse(null, starttime) // }) // // video.on('error', (err) =&gt; { // onResponse(err) // }) // // video.on('progress', (chunkLength, downloaded, total) =&gt; { // fileSize = total // // const floatDownloaded = downloaded / total // // const downloadedMinutes = (Date.now() - starttime) / 1000 / 60 // // readline.cursorTo(process.stdout, 0) // // process.stdout.write(`${(floatDownloaded * 100).toFixed(2)}% downloaded`) // // process.stdout.write(`(${(downloaded / 1024 / 1024).toFixed(2)}MB of ${(total / 1024 / 1024).toFixed(2)}MB)\\n`) // // process.stdout.write(`running for: ${downloadedMinutes.toFixed(2)}minutes`) // // process.stdout.write(`, estimated time left: ${(downloadedMinutes / floatDownloaded - downloadedMinutes).toFixed(2)}minutes `) // // readline.moveCursor(process.stdout, 0, -1) // }) // // video.on('end', () =&gt; { // process.stdout.write('\\n\\n') // // cb(null, output) // }) // // var total = 0 // function updateProgress (chunkLength) { // total += chunkLength // this._ipfs.log('Progress \\t', total, ' / ', fileSize, ' = ', Math.floor((total / fileSize) * 100)) // } // // pull( // pull.values([{ // path: url, // content: pull( // toPull(video), // pull.through((chunk) =&gt; updateProgress(chunk.length)) // ) // }]), // this._node.files.addPullStream({chunkerOptions: {maxChunkSize: this._chunkSize}}), // default size 262144 // this._signalTranscoderPull(callback) // ) // } // // grabVimeo (url, onResponse, callback) { // let starttime // // let total = 0 // let video = vidl(url, {quality: '720p'}) // // video.once('response', () =&gt; { // this._ipfs.log(`starting ${url}`) // starttime = Date.now() // onResponse(null, starttime) // }) // // video.on('data', (chunk) =&gt; { // // total += chunk.length / 1024 / 1024 // }) // // video.on('end', () =&gt; { // // process.stdout.write('\\n\\n') // // cb(null, output) // }) // // function updateProgress (chunkLength) { // // this._ipfs.log('Progress \\t', total, ' / ', fileSize, ' = ', Math.floor((total / fileSize) * 100)) // } // // pull( // pull.values([{ // path: url, // content: pull( // toPull(video), // pull.through((chunk) =&gt; updateProgress(chunk.length)) // ) // }]), // this._node.files.addPullStream({chunkerOptions: {maxChunkSize: this._chunkSize}}), // default size 262144 // this._signalTranscoderPull(callback) // ) // } // } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.transcoder.js.html":{"id":"paratii.transcoder.js.html","title":"Source: paratii.transcoder.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.transcoder.js /* global ArrayBuffer */ 'use strict' import { ipfsSchema } from './schemas.js' import { EventEmitter } from 'events' import joi from 'joi' const Multiaddr = require('multiaddr') /** * IPFS UPLOADER : Paratii IPFS uploader interface. * @extends EventEmitter * @param {ParatiiIPFSUploaderSchema} opts */ export class ParatiiTranscoder extends EventEmitter { /** * @typedef {Array} ParatiiIPFSUploaderSchema * @property {?ipfsSchema} ipfs * @property {?Object} ParatiiIPFS */ constructor (opts) { super() const schema = joi.object({ ipfs: ipfsSchema, paratiiIPFS: joi.object().optional() // onReadyHook: joi.array().ordered().default([]), // protocol: joi.string().default(null), }) const result = joi.validate(opts, schema, {allowUnknown: true}) if (result.error) throw result.error this.config = result.value this._ipfs = this.config.paratiiIPFS // this is the paratii.ipfs.js } /** * signals transcoder(s) to transcode fileHash * @param {string} fileHash IPFS file hash. * @param {Object} options ref: https://github.com/Paratii-Video/paratii-lib/blob/master/docs/paratii-ipfs.md#ipfsuploadertranscodefilehash-options * @return {EvenEmitter} EventEmitter with the following events:&lt;br&gt; * - 'uploader:progress': (hash, chunkSize, percent) client to transcoder upload progress.&lt;br&gt; * - 'transcoding:started': (hash, author)&lt;br&gt; * - 'transcoding:progress': (hash, size, percent)&lt;br&gt; * - 'transcoding:downsample:ready' (hash, size)&lt;br&gt; * - 'transcoding:done': (hash, transcoderResult) triggered when the transcoder is done - returns the hash of the transcoded file&lt;br&gt; * - 'transcoder:error': (err) triggered whenever an error occurs.&lt;br&gt; */ transcode (fileHash, options) { const schema = joi.object({ author: joi.string().default('0x'), // ETH/PTI address of the file owner transcoder: joi.string().default(this.config.ipfs.defaultTranscoder), transcoderId: joi.any().default(Multiaddr(this.config.ipfs.defaultTranscoder).getPeerId()) }).unknown() this._ipfs.log('Signaling transcoder...') const result = joi.validate(options, schema) const error = result.error if (error) throw error let opts = result.value let ev if (opts.ev) { ev = opts.ev } else { ev = new EventEmitter() } if (fileHash === '') { // empty hash for testing eventemitter ev.emit('transcoding:done', {test: 1}) return ev } let msg = this._ipfs.protocol.createCommand('transcode', {hash: fileHash, author: opts.author, size: opts.size}) // FIXME : This is for dev, so we just signal our transcoder node. // This needs to be dynamic later on. this._node.swarm.connect(opts.transcoder, (err, success) =&gt; { if (err) return ev.emit('transcoding:error', err) opts.transcoderId = opts.transcoderId || Multiaddr(opts.transcoder).getPeerId() this._ipfs.log('transcoderId: ', opts.transcoderId) this._node.swarm.peers((err, peers) =&gt; { this._ipfs.log('peers: ', peers) if (err) return ev.emit('transcoding:error', err) peers.map((peer) =&gt; { try { this._ipfs.log('peerID : ', peer.peer.toB58String(), opts.transcoderId, peer.peer.toB58String() === opts.transcoder) if (peer.peer.toB58String() === opts.transcoderId) { this._ipfs.log(`sending transcode msg to ${peer.peer.toB58String()} with request to transcode ${fileHash}`) this._ipfs.protocol.network.sendMessage(peer.peer, msg, (err) =&gt; { if (err) { ev.emit('transcoding:error', err) return ev } }) } } catch (e) { console.log('PEER ERROR :', e, peer) } }) // paratii transcoder signal. this._ipfs.on('protocol:incoming', this._transcoderRespHander(ev, fileHash)) }) }) return ev } /** * handles responses from the paratii-protocol in case of transcoding. * @param {EventEmitter} ev the transcoding job EventEmitter * @return {function} returns various events based on transcoder response. * @example ? * @private */ _transcoderRespHander (ev, fileHash) { return (peerId, command) =&gt; { this._ipfs.log('paratii protocol: Received command ', command.payload.toString(), 'args: ', command.args.toString()) let commandStr = command.payload.toString() let argsObj try { argsObj = JSON.parse(command.args.toString()) } catch (e) { this._ipfs.error('couldn\\'t parse args, ', command.args.toString()) } switch (commandStr) { case 'transcoding:error': console.log('DEBUG TRANSCODER ERROR: fileHash: ', fileHash, ' , errHash: ', argsObj.hash) if (argsObj.hash === fileHash) { ev.emit('transcoding:error', argsObj.err) } break case 'transcoding:started': if (argsObj.hash === fileHash) { ev.emit('transcoding:started', argsObj.hash, argsObj.author) } break case 'transcoding:progress': if (argsObj.hash === fileHash) { ev.emit('transcoding:progress', argsObj.hash, argsObj.size, argsObj.percent) } break case 'uploader:progress': if (argsObj.hash === fileHash) { ev.emit('uploader:progress', argsObj.hash, argsObj.chunkSize, argsObj.percent) } break case 'transcoding:downsample:ready': if (argsObj.hash === fileHash) { ev.emit('transcoding:downsample:ready', argsObj.hash, argsObj.size) } break case 'transcoding:done': if (argsObj.hash === fileHash) { let result = JSON.parse(argsObj.result.toString()) ev.emit('transcoding:done', argsObj.hash, result) } break default: if (argsObj.hash === fileHash) { this._ipfs.log('unknown command : ', commandStr) } } } } /** * convenience method for adding and transcoding files * @param {Array} files Array of HTML5 File Objects */ addAndTranscode (files) { let ev = this._ipfs.local.upload(files) // ev.on('done', this._signalTranscoder.bind(this)) ev.on('done', (files) =&gt; { this._signalTranscoder(files, ev) }) return ev } /** * [_signalTranscoder description] * TODO RIVEDI I TIPI * @param {Object} files [description] * @param {Object} ev [description] * @return {Object} [description] * @private */ _signalTranscoder (files, ev) { let file if (Array.isArray(files)) { if (files.length &lt; 1) { // FIXME THIS NEEDS TO BE REMOVED file = {hash: ''} // testing something ... // this._ipfs.log('_signalTranscoder Got an empty Array. files: ', files) // return } else { file = files[0] } } else { file = files } if (!ev) { ev = new EventEmitter() } this.transcode(file.hash, { author: '0x', // author address, ev: ev }) } /** * [getMetaData description] * @param {Object} fileHash [description] * @param {Object} options [description] * @return {Object} [description] */ getMetaData (fileHash, options) { return new Promise((resolve, reject) =&gt; { const schema = joi.object({ transcoder: joi.string().default(this.config.ipfs.defaultTranscoder), transcoderId: joi.any().default(Multiaddr(this.config.ipfs.defaultTranscoder).getPeerId()) }).unknown() this._ipfs.log('Signaling transcoder getMetaData...') const result = joi.validate(options, schema) const error = result.error if (error) reject(error) let opts = result.value console.log('opts: ', opts) let ev if (opts.ev) { ev = opts.ev } else { ev = new EventEmitter() } this._ipfs.start().then(() =&gt; { let msg = this._ipfs.protocol.createCommand('getMetaData', {hash: fileHash}) // FIXME : This is for dev, so we just signal our transcoder node. // This needs to be dynamic later on. this._ipfs.ipfs.swarm.connect(opts.transcoder, (err, success) =&gt; { if (err) return reject(err) opts.transcoderId = opts.transcoderId || Multiaddr(opts.transcoder).getPeerId() this._ipfs.log('transcoderId: ', opts.transcoderId) this._node.swarm.peers((err, peers) =&gt; { this._ipfs.log('peers: ', peers) if (err) return reject(err) peers.map((peer) =&gt; { this._ipfs.log('peerID : ', peer.peer.id.toB58String(), opts.transcoderId, peer.peer.id.toB58String() === opts.transcoder) if (peer.peer.id.toB58String() === opts.transcoderId) { this._ipfs.log(`sending getMetaData msg to ${peer.peer.id.toB58String()} with request to transcode ${fileHash}`) this._ipfs.protocol.network.sendMessage(peer.peer.id, msg, (err) =&gt; { if (err) { ev.emit('getMetaData:error', err) return ev } }) } }) // paratii getMetaData signal. this._ipfs.on('protocol:incoming', (peerId, command) =&gt; { this._ipfs.log('paratii protocol: Received command ', command.payload.toString(), 'args: ', command.args.toString()) let commandStr = command.payload.toString() let argsObj try { argsObj = JSON.parse(command.args.toString()) } catch (e) { this._ipfs.error('couldn\\'t parse args, ', command.args.toString()) } switch (commandStr) { case 'getMetaData:error': if (argsObj.hash === fileHash) { console.log('DEBUG getMetaData ERROR: fileHash: ', fileHash, ' , errHash: ', argsObj.hash) reject(argsObj.err) } break case 'getMetaData:done': if (argsObj.hash === fileHash) { console.log('data: ', argsObj.data) let result = argsObj.data resolve(result) } break default: this._ipfs.log('unknown command : ', commandStr) } }) }) }) }) }) } // grabYt (url, onResponse, callback) { // let starttime // let fileSize // let video = ytdl(url) // video.once('response', () =&gt; { // this._ipfs.log(`starting ${url}`) // starttime = Date.now() // onResponse(null, starttime) // }) // // video.on('error', (err) =&gt; { // onResponse(err) // }) // // video.on('progress', (chunkLength, downloaded, total) =&gt; { // fileSize = total // // const floatDownloaded = downloaded / total // // const downloadedMinutes = (Date.now() - starttime) / 1000 / 60 // // readline.cursorTo(process.stdout, 0) // // process.stdout.write(`${(floatDownloaded * 100).toFixed(2)}% downloaded`) // // process.stdout.write(`(${(downloaded / 1024 / 1024).toFixed(2)}MB of ${(total / 1024 / 1024).toFixed(2)}MB)\\n`) // // process.stdout.write(`running for: ${downloadedMinutes.toFixed(2)}minutes`) // // process.stdout.write(`, estimated time left: ${(downloadedMinutes / floatDownloaded - downloadedMinutes).toFixed(2)}minutes `) // // readline.moveCursor(process.stdout, 0, -1) // }) // // video.on('end', () =&gt; { // process.stdout.write('\\n\\n') // // cb(null, output) // }) // // var total = 0 // function updateProgress (chunkLength) { // total += chunkLength // this._ipfs.log('Progress \\t', total, ' / ', fileSize, ' = ', Math.floor((total / fileSize) * 100)) // } // // pull( // pull.values([{ // path: url, // content: pull( // toPull(video), // pull.through((chunk) =&gt; updateProgress(chunk.length)) // ) // }]), // this._node.files.addPullStream({chunkerOptions: {maxChunkSize: this._chunkSize}}), // default size 262144 // this._signalTranscoderPull(callback) // ) // } // // grabVimeo (url, onResponse, callback) { // let starttime // // let total = 0 // let video = vidl(url, {quality: '720p'}) // // video.once('response', () =&gt; { // this._ipfs.log(`starting ${url}`) // starttime = Date.now() // onResponse(null, starttime) // }) // // video.on('data', (chunk) =&gt; { // // total += chunk.length / 1024 / 1024 // }) // // video.on('end', () =&gt; { // // process.stdout.write('\\n\\n') // // cb(null, output) // }) // // function updateProgress (chunkLength) { // // this._ipfs.log('Progress \\t', total, ' / ', fileSize, ' = ', Math.floor((total / fileSize) * 100)) // } // // pull( // pull.values([{ // path: url, // content: pull( // toPull(video), // pull.through((chunk) =&gt; updateProgress(chunk.length)) // ) // }]), // this._node.files.addPullStream({chunkerOptions: {maxChunkSize: this._chunkSize}}), // default size 262144 // this._signalTranscoderPull(callback) // ) // } // } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"paratii.eth.wallet.js.html":{"id":"paratii.eth.wallet.js.html","title":"Source: paratii.eth.wallet.js","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Source: paratii.eth.wallet.js // this code is lifted and adapted from ethereumjs-lightwallet import {add0x} from './utils.js' var bip39 = require('bip39') var hdkey = require('hdkey') /** * overrides some web3js wallet functionalties * @param {Object} wallet wallet to patch * @param {Object} config configuration object to initialize Paratii object * @return {Object} patched wallet * @private */ export function patchWallet (wallet, config) { /** * Create a wallet with a given number of accounts from a BIP39 mnemonic * @param {number} numberOfAccounts number of accounts to be created * @param {?string} mnemonic mnemonic of the wallet, if not specified a random one is generated * @return {Object} the created wallet * @example wallet = await wallet.create(5, 'some long mnemonic phrase') */ async function create (numberOfAccounts, mnemonic) { if (this.length &gt; 0) { throw Error('This wallet has already been created!') } if (numberOfAccounts === undefined) { numberOfAccounts = 1 } if (mnemonic === undefined) { mnemonic = bip39.generateMnemonic() } if (bip39.validateMnemonic(mnemonic)) { let seed = bip39.mnemonicToSeed(mnemonic) // contains masternode extended priv key and extended pub key let masternode = hdkey.fromMasterSeed(seed) for (let i = 0; i &lt; numberOfAccounts; ++i) { // m / purpose' / coin_type' / account' / change / address_index let child = masternode.derive(`m/44'/60'/0'/0/${i}`) let privkeyHex = child.privateKey.toString('hex') var privateKey = this._accounts.privateKeyToAccount(add0x(privkeyHex)).privateKey this.add(privateKey) } } else { throw Error(`Mnemonic was not valid: ${mnemonic}`) } return this } /** * check if the passed mnemonic is bip39 valid * @param {string} mnemonic mnemonic to check * @return {Boolean} true if the mnemonic is valid, false otherwise * @example paratii.eth.wallet.isValidMnemonic('some long mnemonic phrase') */ function isValidMnemonic (mnemonic) { return bip39.validateMnemonic(mnemonic) } /** * generates a new mnemonic * @return {string} newly generated mnemonic * @example let newMnemonic = paratii.eth.wallet.generateMnemonic() */ function newMnemonic () { return bip39.generateMnemonic() } /* function getMnemonic () { return this._mnemonic } function setPassphrase (passphrase) { this._passphrase = passphrase return this._passphrase } */ let origDecrypt = wallet.decrypt.bind(wallet) /** * decrypts the wallet * @param {Object} data encrypted wallet * @param {string} password password to decrypt * @return {Object} decrypted wallet * @example let decryptedWallet = paratii.eth.wallet._decrypt(encryptedWallet,'some-psw') */ function _decrypt (data, password) { let newWallet = origDecrypt(data, password) if (newWallet) { config.paratii.eth.setAccount(newWallet['0'].address, newWallet['0'].privateKey) } return newWallet } // wallet._mnemonic = undefined // testing purpose // wallet._passphrase = '' // wallet.setPassphrase = setPassphrase wallet.create = create wallet.decrypt = _decrypt wallet.isValidMnemonic = isValidMnemonic wallet.newMnemonic = newMnemonic // wallet.getMnemonic = getMnemonic return wallet } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Global Type Definitions accountSchema Type: Array Properties: Name Type Argument Description address string &lt;nullable&gt; public address of the account privateKey string &lt;nullable&gt; private key of the account mnemonic string &lt;nullable&gt; mnemonic that generates private key and address Source: schemas.js dbSchema Type: Array Properties: Name Type Argument Description provider string &lt;nullable&gt; provider of the db Source: schemas.js ethSchema Type: Array Properties: Name Type Argument Description provider string &lt;nullable&gt; provider of the parity node registryAddress string &lt;nullable&gt; address of the TCR isTestNet boolean &lt;nullable&gt; true if it's on test net, false otherwise Source: schemas.js ipfsSchema Type: Array Properties: Name Type Argument Description repo string &lt;nullable&gt; path to the ipfs repo swarm Array available transports for ipfs (webrtc, websocket, ...) bootstrap Array bootstrap nodes that ipfs connects to when it starts bitswap.maxMessageSize number &lt;nullable&gt; the maximum msg size allowed for paratii-ipfs-bitswap chunkSize number &lt;nullable&gt; max size allowed per file chunk xhrChunkSize number &lt;nullable&gt; max chunk size for the express uploader maxFileSize number &lt;nullable&gt; max size for an original video (default to 300MB) defaultTranscoder string &lt;nullable&gt; the default multiaddress of the main paratii-node remoteIFPFSNode string &lt;nullable&gt; the default multiaddress of the main paratii-node transcoderDropUrl string &lt;nullable&gt; url for the express uploader Source: schemas.js ParatiiConfigSchema Type: Array Properties: Name Type Argument Description account accountSchema &lt;nullable&gt; eth ethSchema &lt;nullable&gt; db dbSchema &lt;nullable&gt; ipfs ipfsSchema &lt;nullable&gt; Source: paratii.js ParatiiDbSchema Properties: Name Type Description db dbSchema account accountSchema Source: paratii.db.js ParatiiEthSchema Type: Array Properties: Name Type Argument Description account accountSchema &lt;nullable&gt; eth ethSchema &lt;nullable&gt; Source: paratii.eth.js ParatiiIPFSSchema Type: Array Properties: Name Type Argument Description ipfs ipfsSchema &lt;nullable&gt; account accountSchema &lt;nullable&gt; verbose boolean &lt;nullable&gt; Source: paratii.ipfs.js ParatiiIPFSUploaderSchema Type: Array Properties: Name Type Argument Description ipfs ipfsSchema &lt;nullable&gt; ParatiiIPFS Object &lt;nullable&gt; Source: paratii.ipfs.remote.js ParatiiIPFSUploaderSchema Type: Array Properties: Name Type Argument Description ipfs ipfsSchema &lt;nullable&gt; ParatiiIPFS Object &lt;nullable&gt; Source: paratii.transcoder.js ParatiiIPFSUploaderSchema Type: Array Properties: Name Type Argument Description ipfs ipfsSchema &lt;nullable&gt; ParatiiIPFS Object &lt;nullable&gt; Source: paratii.ipfs.local.js videoSchema Type: Array Properties: Name Type Argument Description id string &lt;nullable&gt; univocal video identifier randomly generated author string &lt;nullable&gt; author of the video description string &lt;nullable&gt; description of the video duration string &lt;nullable&gt; duration of the video filename string &lt;nullable&gt; filename of the video filesize number size of the video free string &lt;nullable&gt; ? ipfsHashOrig string &lt;nullable&gt; original ipfs multihash of the video ipfsHash string &lt;nullable&gt; ipfs multihash of the video owner string owner of the video price number &lt;nullable&gt; price of the video title string &lt;nullable&gt; title of the video thumbnails Array thumbnails of the video storageStatus Object &lt;nullable&gt; ? Properties Name Type Argument Description name string ? data Object &lt;nullable&gt; ? transcodingStatus Object &lt;nullable&gt; ? Properties Name Type Argument Description name string ? data Object &lt;nullable&gt; ? uploadStatus Object &lt;nullable&gt; ? Properties Name Type Argument Description name string ? data Object &lt;nullable&gt; ? Source: schemas.js Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Classes Classes Paratii ParatiiCoreUsers ParatiiCoreVids ParatiiDb ParatiiDbUsers ParatiiDbVids ParatiiEth ParatiiEthEvents ParatiiEthTcr ParatiiEthUsers ParatiiEthVids ParatiiEthVouchers ParatiiIPFS ParatiiIPFSLocal ParatiiIPFSRemote ParatiiTranscoder Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global paratii.js paratii.js is the main entry point and abstraction layer to interact with Paratii, a decentralized platform for video distribution. More information about the Paratii Project can be found on paratii.video, or in our blueprint. Join the discussion on gitter. InstallationYou can install paratii-js from npmjs.org using: npm install paratii-jsHow to use itHere is a code snippet which will upload a video to Paratii and transcode it: // import the Paratii object const Paratii = require('paratii-js') // create a new instance of Paratii with default values const paratii = new Paratii() // where is your video? const YOURVID = '/path/to/video.mp4' // go and add the video paratii.vids.uploadAndTranscode({ file: YOURVID, title: 'Paratii for fun and profit' })We have more extensive documentation here: documentation.md Contributing to paratii.jsContributions are most welcome! Please read CONTRIBUTING.md Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"Paratii.html":{"id":"Paratii.html","title":"Class: Paratii","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: Paratii Paratii Paratii library main object The Paratii object serves as the general entry point for interacting with the family of Paratii contracts that are deployed on the blockchain, utilities to run and interact with a local IPFS node, and utilities to interact with the Paratii index. new Paratii(opts) Parameters: Name Type Description opts ParatiiConfigSchema options object to configure paratii library Properties: Name Type Description vids ParatiiCoreVids operations on videos users ParatiiCoreUsers operations on users eth ParatiiEth interact with the Ethereum blockchain ipfs ParatiiIPFS interact with the IPFS instance db ParatiiDb interact with the Paratii Index transcoder ParatiiTranscoder commands for transcoding files Source: paratii.js Example import Paratii from 'paratii-js' paratii = new Paratii({ eth: { provider': 'http://localhost:8545' }, account: { address: 'your-address' } }) Methods &lt;async&gt; diagnose() Get some diagnostic info about the state of the system Source: paratii.js Returns: that resolves in an array of strings with diagnostic info Type Promise Example let diagnosticInfo = await paratii.diagnose() console.log(diagnosticInfo) getAccount() Gets the ethereum address that is used to sign all the transactions Source: paratii.js Example paratii.getAccount() getRegistryAddress(address) Sets the address of the ParatiiRegistry contract Parameters: Name Type Description address string address of the ParatiiRegistry contract Source: paratii.js Example paratii.getRegistryAddress() setAccount(address, privateKey, mnemonic) Sets the account that will be used to sign all transactions Parameters: Name Type Argument Description address string &lt;nullable&gt; public address privateKey string &lt;nullable&gt; private key related to the previous public address mnemonic string &lt;nullable&gt; mnemonic related to the previous public address Source: paratii.js Examples paratii.eth.setAccount(null,'some-private-key') paratii.eth.setAccount('some-address', null, 'some-mnemonic') setRegistryAddress(address) Sets the address of the ParatiiRegistry contract Parameters: Name Type Description address string address of the ParatiiRegistry contract Source: paratii.js Example paratii.eth.setRegistryAddress('0x12345') Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiCoreUsers.html":{"id":"ParatiiCoreUsers.html","title":"Class: ParatiiCoreUsers","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiCoreUsers ParatiiCoreUsers Utilities to create and manipulate information about the users on the blockchain. new ParatiiCoreUsers(config) Parameters: Name Type Description config Object configuration object to initialize Paratii object Source: paratii.core.users.js Methods &lt;async&gt; create(options) Creates a user, fields id, name and email go to the smart contract Users, other fields are stored on IPFS. Parameters: Name Type Description options userSchema information about the video ( id, name, email ... ) Source: paratii.core.users.js Returns: the id of the newly created user Type Promise Example paratii.users.create({ id: 'some-user-id', name: 'A user name', email: 'some@email.com', ... }) get(id) retrieve data about the user Parameters: Name Type Description id string user univocal id Source: paratii.core.users.js Returns: data about the user Type Object Example paratii.users.get('some-user-id') &lt;async&gt; migrateAccount(newAccount) migrate all contract data for paratii.config.account to a new account Parameters: Name Type Description newAccount Address of new account Source: paratii.core.users.js &lt;async&gt; update(userId, options) Updates a user's details. name and email are defined in the smart contract Users, other fields get written to IPFS. Parameters: Name Type Description userId string user univocal id options Object updated data i.e. { name: 'A new user name' } Source: paratii.core.users.js Returns: updated data about the user Type Promise Example paratii.users.update('some-user-id', {name: 'A new user name'}) Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiCoreVids.html":{"id":"ParatiiCoreVids.html","title":"Class: ParatiiCoreVids","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiCoreVids ParatiiCoreVids Utilities to create and manipulate information about the videos on the blockchain. new ParatiiCoreVids(config) Parameters: Name Type Description config Object configuration object to initialize Paratii object Source: paratii.core.vids.js Methods &lt;async&gt; create(options) This call will register the video on the blockchain, add its metadata to IPFS, upload file to IPFS, and transcode it Parameters: Name Type Description options videoSchema information about the video ( id, title, FilePath ... ) Source: paratii.core.vids.js Returns: information about the video ( id, owner, ipfsHash ... ) Type Promise Example await paratii.core.vids.create({ id: 'some-video-id', owner: 'some-user-id', title: 'some Title', author: 'Steven Spielberg', duration: '2h 32m', description: 'A long description', price: 0, filename: 'test/data/some-file.txt' }) dislike(videoId) Writes a dislike for the video on the blockchain (contract Likes), and negates a like for the video, if it exists. Parameters: Name Type Description videoId string univocal video identifier randomly generated Source: paratii.core.vids.js Returns: information about the transaction recording the dislike Type Object Example paratii.core.vids.dislike('some-video-id') doesDislike(videoId) Check if the current user has already disliked the video Parameters: Name Type Description videoId string univocal video identifier randomly generated Source: paratii.core.vids.js Returns: true if the current user already disliked the video, false otherwise Type Boolean Example paratii.core.vids.doesDislike('some-video-id') doesLike(videoId) Check if the current user has already liked the video Parameters: Name Type Description videoId string univocal video identifier randomly generated Source: paratii.core.vids.js Returns: true if the current user already liked the video, false otherwise Type Boolean Example paratii.core.vids.doesLike('some-video-id') &lt;async&gt; get(videoId) Get the data of the video identified by videoId Parameters: Name Type Description videoId string univocal video identifier randomly generated Source: paratii.core.vids.js Returns: data about the video Type Promise Example paratii.core.vids.get('some-video-id') hasViewedVideo(viewer, videoId) Check if the viewer has already viewed the video Parameters: Name Type Description viewer string viewer address videoId string univocal video identifier randomly generated Source: paratii.core.vids.js Returns: true if the current user already viewed the video, false otherwise Type Boolean Example paratii.core.vids.hasViewedVideo('some-user-id','some-video-id') like(videoId) Writes a like for the video on the blockchain (contract Likes), and negates a dislike for the video, if it exists. Parameters: Name Type Description videoId string univocal video identifier randomly generated Source: paratii.core.vids.js Returns: information about the transaction recording the like Type Object Example paratii.core.vids.like('some-video-id') search(options) Get the data of the video Parameters: Name Type Description options Object data about the video and (optional) owner i.e {'keyword':'titleOfTheVideo'} Source: paratii.core.vids.js Returns: data about the video Type Promise Example paratii.core.vids.search({keyword : 'titleOftheVideo'}) the keyword value can be one from the following list - video title - description - owner - uploader.name - uploader.address - tags &lt;async&gt; update(videoId, options, dataToUpdate) Update the information on the video. Only the account that has registered the video, or the owner of the contract, can update the information. Parameters: Name Type Description videoId string univocal video identifier options Object key value pairs of properties and new values e.g. ({title: 'another-title'}) dataToUpdate Object optional. old data of the video. If not passed to the method, it will fetch the data itself using the videoId Source: paratii.core.vids.js Returns: Updated video informations Type Promise Example paratii.core.vids.update('some-video-id', {title: 'another-title'}) &lt;async&gt; upsert(options) Update the information of the video the video already exists, otherwise it creates it Parameters: Name Type Description options Object video informations Source: paratii.core.vids.js Returns: updated/new video informations Type Promise Example paratii.vids.upsert({ id: 'some-video-id', owner: 'some-user-id', title: 'videoTitle'}) //insert a new video &lt;async&gt; view(options) Register a view on the blockchain Parameters: Name Type Description options Object should contain keys viewer (address of the viewer) and videoId (univocal video identifier) Source: paratii.core.vids.js Returns: information about the transaction recording the view Type Promise Example paratii.core.vids.view({viewer:'some-user-id',videoId: 'some-video-id'}) Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiDb.html":{"id":"ParatiiDb.html","title":"Class: ParatiiDb","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiDb ParatiiDb ParatiiDb contains a functionality to interact with the Paratii Index. new ParatiiDb(config) Parameters: Name Type Description config ParatiiDbSchema configuration object to initialize Paratii object Properties: Name Type Description vids ParatiiCoreVids operations on videos users ParatiiCoreUsers operations on users Source: paratii.db.js Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiDbUsers.html":{"id":"ParatiiDbUsers.html","title":"Class: ParatiiDbUsers","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiDbUsers ParatiiDbUsers ParatiiDbUsers contains functionalities regarding the users to interact with the Paratii Blockchain Index new ParatiiDbUsers(config) Parameters: Name Type Description config Object object to initialize Paratii object Source: paratii.db.users.js Methods &lt;async&gt; get(userId) retrieve data about the user Parameters: Name Type Description userId string user univocal id Source: paratii.db.users.js Returns: data about the user Type Promise Example paratii.db.users.get('some-user-id') &lt;async&gt; videos(userId) get information about all the videos of the user Parameters: Name Type Description userId string univocal user identifier Source: paratii.db.users.js Returns: Collection of all the videos of the user Type Promise Example paratii.db.users.videos('some-user-id') Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiDbVids.html":{"id":"ParatiiDbVids.html","title":"Class: ParatiiDbVids","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiDbVids ParatiiDbVids ParatiiDbUsers contains functionalities regarding the videos to interact with the Paratii Blockchain Index new ParatiiDbVids(config) Parameters: Name Type Description config Object object to initialize Paratii object Source: paratii.db.vids.js Methods &lt;async&gt; get(videoId) Get information about this video from the db Parameters: Name Type Description videoId string univocal video identifier randomly generated Source: paratii.db.vids.js Returns: data about the video Type Promise Example paratii.db.vids.get('some-video-id') &lt;async&gt; search(options) Get the data of the video Parameters: Name Type Description options Object data about the video and (optional) owner i.e {'keyword':'titleOfTheVideo'} Source: paratii.db.vids.js Returns: data about the video Type Promise Example paratii.db.vids.search({keyword : 'titleOftheVideo'}) the keyword value can be one from the following list - video title - description - owner - uploader.name - uploader.address - tags Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiEth.html":{"id":"ParatiiEth.html","title":"Class: ParatiiEth","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiEth ParatiiEth contains functions to interact with the Ethereum blockchain and the Paratii contracts. See Paratii new ParatiiEth(config) Parameters: Name Type Description config ParatiiEthSchema configuration object to initialize Paratii object Properties: Name Type Description vids ParatiiCoreVids operations on videos users ParatiiCoreUsers operations on users events ParatiiEthEvents manage subscriptions to Ethereum events vouchers ParatiiEthVouchers Functions for redeeming vouchers tcr ParatiiEthTcr TCR functionality Source: paratii.eth.js Example let paratii = new Paratii() // paratii.eth is an instance of ParatiiEth; let's check the PTI balance of an account paratii.eth.balanceOf('0xCbe4f07b343171ac37055B25a5266f48f6945b7d', 'PTI') Methods &lt;async&gt; balanceOf(address [, symbol]) When called with a second argument, returns the balance of that Token. When called without a second argument, returns information about all relevant balances. Parameters: Name Type Argument Description address string ethereum address symbol string &lt;optional&gt; symbol of the token (ETH,PTI) Source: paratii.eth.js Returns: information about balances of that address Type Promise Example // returns the ETH balance of the given address await paratii.eth.balanceOf('some-address', 'ETH') // returns the PTI balance of the given address await paratii.eth.balanceOf('some-address', 'PTI') // returns both the PTI and the ETH balance of the given address await paratii.eth.balanceOf('some-address') &lt;async&gt; deployContract(name, args) deploys contract on the blockchain Parameters: Name Type Argument Description name string name of the contract args Object &lt;repeatable&gt; configuration for the contract (strings or numbers). It is allowed to pass more than one parameter Source: paratii.eth.js Returns: the deployed contract Type Promise Examples paratii.eth.deployContract('ParatiiToken') let paratiiRegistryAddress = await paratii.eth.getRegistryAddress() let likes = await this.deployContract('Likes', paratiiRegistryAddress) &lt;async&gt; deployContracts() deploy all Paratii contracts on the blockchain, and register them the registry contract Source: paratii.eth.js Returns: all the paratii contracts Type Promise Example let contracts = await paratii.eth.deployContracts() for (contractName in contracts) { console.log(contracts[contractName])} &lt;async&gt; getContract(name) Get the contract instance specified Parameters: Name Type Description name string the name of the token Source: paratii.eth.js Returns: Object representing the contract Type Promise Example paratii.eth.getContract('ParatiiToken') &lt;async&gt; getContractAddress(name) get the address of the contract on the blockchain Parameters: Name Type Description name string name of the contract Source: paratii.eth.js Returns: Contract address on the blockchain (String) Type Promise Example paratii.eth.getContractAddress('ParatiiToken') &lt;async&gt; getContracts() return all the contracts Source: paratii.eth.js Returns: Type Promise Examples let contracts = await paratii.eth.getContracts() let contracts = await paratii.eth.deployContracts() for (contractName in contracts) { console.log(contracts[contractName])} &lt;async&gt; transfer(beneficiary, amount, symbol, description) Use this to send ETH or PTI from paratii.config.address Parameters: Name Type Argument Description beneficiary string ETH address amount number amount of ETH/PTI to be sent symbol string symbol of the token to send (ETH,PTI) description string &lt;nullable&gt; description to be inserted in the blockchain Source: paratii.eth.js Returns: information about the transaction recording the transfer Type Promise Example let result = await paratii.eth.transfer('some-address', 20, 'ETH', 'thanks for all the fish') Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiEthEvents.html":{"id":"ParatiiEthEvents.html","title":"Class: ParatiiEthEvents","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiEthEvents ParatiiEthEvents eth.events implements a part of the API of the EventEmitter, that can be used to manage subscriptions to Ethereum events. new ParatiiEthEvents(config) Parameters: Name Type Description config Object configuration object to initialize Paratii object Source: paratii.eth.events.js Methods &lt;async&gt; _addListener(eventType, listener, options) [_addListener description] TODO RIVEDI I TIPI Parameters: Name Type Description eventType Object [description] listener Object [description] options Object [description] Source: paratii.eth.events.js Returns: [description] Type Promise _getStructuredEvent(eventType) parse event from simple string to an object Parameters: Name Type Description eventType string Event type Source: paratii.eth.events.js Returns: Event Object Type Object Example let structuredEvent = this._getStructuredEvent('some-event') _isFunction(functionToCheck) [_isFunction description] TODO RIVEDI I TIPI Parameters: Name Type Description functionToCheck Object [description] Source: paratii.eth.events.js Returns: [description] Type Boolean &lt;async&gt; addListener(eventType, options, listener) subscribe to the specified event Parameters: Name Type Description eventType string type of the event options function function called when the events occurs listener ? optional ? Source: paratii.eth.events.js Returns: [description] Type Promise addSubscription(eventType, subscription) [addSubscription description] TODO RIVEDI I TIPI Parameters: Name Type Description eventType Object [description] subscription Object [description] Source: paratii.eth.events.js removeAllSubscriptions(eventType) [removeAllSubscriptions description] TODO RIVEDI I TIPI Parameters: Name Type Description eventType Object [description] Source: paratii.eth.events.js Returns: [description] Type Object Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiEthTcr.html":{"id":"ParatiiEthTcr.html","title":"Class: ParatiiEthTcr","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiEthTcr ParatiiEthTcr Token Curated Registry functionalities new ParatiiEthTcr(context) Parameters: Name Type Description context Object ParatiiEth instance Properties: Name Type Description eth ParatiiEth ParatiiEth instance Source: paratii.eth.tcr.js Methods &lt;async&gt; apply(videoId, amountToStake) start the application process. NOTE that this require the client approves PTI amount first before actually running this function, use checkEligiblityAndApply instead. Parameters: Name Type Description videoId string univocal video identifier randomly generated amountToStake Float number of tokens to stake. must &gt;= minDeposit Source: paratii.eth.tcr.js Returns: returns true if all is good, plus _Application event. Type boolean Example let result = await paratii.eth.tcr.apply('some-video-id', 'amount of tokens') &lt;async&gt; checkEligiblityAndApply(videoId, amountToStake) Stake amountToStake on video with id videoId does a number of separate steps: - check preconditions for staking - approve that the TCR contract can transfer amountToStake tokens - apply to the TCR Parameters: Name Type Description videoId string univocal video identifier randomly generated amountToStake number number of tokens to stake Source: paratii.eth.tcr.js Returns: returns true if all is good, plus _Application event. Type Promise Example let result = await paratii.eth.tcr.checkEligiblityAndApply('some-video-id', 'amount of tokens') &lt;async&gt; didVideoApply(videoId) check whether a video started the application process or not yet. Parameters: Name Type Description videoId string univocal video identifier randomly generated Source: paratii.eth.tcr.js Returns: true if video started the application process, false otherwise Type boolean Example let appWasMade = await paratii.eth.tcr.didVideoApply('some-video-id') &lt;async&gt; exit(videoId) remove the video given by videoId from the listing Parameters: Name Type Description videoId univocal video identifier randomly generated Source: paratii.eth.tcr.js Returns: information about the transaction Example let tx = await paratii.eth.tcr.exit('some-video-id') &lt;async&gt; getMinDeposit() get the minimum amount required to stake a video. Source: paratii.eth.tcr.js To Do: return amount as bignumber.js Object Returns: amount required in PTI Type Float Example let minDeposit = await paratii.eth.tcr.getMinDeposit() &lt;async&gt; getTcrContract() get TCR contract instance. Source: paratii.eth.tcr.js Returns: The TCR Contract instance. Type Promise Example let contract = await paratii.eth.tcr.getTcrContract() &lt;async&gt; isWhitelisted(videoId) check if video is already whitelisted or not. note that this returns false till the video is actually whitelisted. use didVideoApply in case you want to check whether the video is in application process. Parameters: Name Type Description videoId string univocal video identifier randomly generated Source: paratii.eth.tcr.js Returns: true if video is whitelisted, false otherwise Type boolean Example let isWhitelisted = await paratii.eth.tcr.isWhitelisted('some-video-id') Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiEthUsers.html":{"id":"ParatiiEthUsers.html","title":"Class: ParatiiEthUsers","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiEthUsers ParatiiEthUsers The eth.user namespace contains functions to interact with the video registration on the blockchain. new ParatiiEthUsers(context) Parameters: Name Type Description context Object ParatiiEth instance Properties: Name Type Description eth ParatiiEth ParatiiEth instance Source: paratii.eth.users.js Methods &lt;async&gt; create(options) Creates a user Parameters: Name Type Description options Object information about the user Properties Name Type Description id string valid address name string name of the user email string email of the user ipfsData string ipfs hash Source: paratii.eth.users.js Returns: the id of the newly created user Type Promise Example let userData = { id: 'some-id', name: 'Humbert Humbert', email: 'humbert@humbert.ru', ipfsData: 'some-hash' } let result = await paratii.eth.users.create(userData) &lt;async&gt; delete(userId) Deletes a user from the blockchain. Can only be called by the contract owner or the user him/her-self Parameters: Name Type Description userId string valid address Source: paratii.eth.users.js Returns: blockchain transaction Type Promise Example await paratii.eth.users.delete('some-id') &lt;async&gt; get(userId) Get a users details from the blockchain Parameters: Name Type Description userId string valid address Source: paratii.eth.users.js Returns: information about the user Type Promise Example user = await paratii.eth.users.get('some-id') &lt;async&gt; getRegistry() Get the contract instance of the user contract Source: paratii.eth.users.js Returns: Object representing the contract Type Promise &lt;async&gt; update(userId, options) Updates a user details on the blockchain. Parameters: Name Type Description userId string valid address options Object information to update. Left-out data is kept the same. Source: paratii.eth.users.js Returns: updated data Type Promise Example await paratii.eth.users.update('some-id', {ipfsData: 'new-hash'}) Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiEthVids.html":{"id":"ParatiiEthVids.html","title":"Class: ParatiiEthVids","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiEthVids ParatiiEthVids The eth.vids namespace contains functions to interact with the video registration on the blockchain. new ParatiiEthVids(context) Parameters: Name Type Description context Object ParatiiEth instance Properties: Name Type Description eth ParatiiEth ParatiiEth instance Source: paratii.eth.vids.js Methods &lt;async&gt; create(options [, retry]) Record the video on the blockchain Parameters: Name Type Argument Default Description options Object data about the video retry number &lt;optional&gt; 1 optional, default = 1 Source: paratii.eth.vids.js Returns: the video id Type Promise Example let videoId = await paratii.eth.vids.create({ id: 'some-id', price: 20, owner: 'some-address', ipfsHash: 'some-hash' }) &lt;async&gt; delete(videoId) delete the video from the blockchain Parameters: Name Type Description videoId string univocal video identifier randomly generated Source: paratii.eth.vids.js Returns: transaction recording the remove action Type Promise Example let tx = paratii.eth.vids.delete('some-id') &lt;async&gt; dislike(videoId) Writes a dislike for the video on the blockchain (contract Likes), and negates a like for the video, if it exists. Parameters: Name Type Description videoId string univocal video identifier randomly generated Source: paratii.eth.vids.js Returns: transaction recording the dislike Type Promise Example let result = paratii.eth.vids.dislike('some-id') &lt;async&gt; doesDislike(videoId) Check if the current user has already disliked the video. Parameters: Name Type Description videoId string univocal video identifier randomly generated Source: paratii.eth.vids.js Returns: true if the current user already disliked the video, false otherwise Type Promise Example let result = paratii.eth.vids.doesDislike('some-id') &lt;async&gt; doesLike(videoId) Check if the current user has already liked the video Parameters: Name Type Description videoId string univocal video identifier randomly generated Source: paratii.eth.vids.js Returns: true if the current user already liked the video, false otherwise Type Promise Example let result = paratii.eth.vids.doesLike('some-id') &lt;async&gt; get(videoId) get data about the video Parameters: Name Type Description videoId string univocal video id Source: paratii.eth.vids.js Returns: data about the video Type Promise Example let video = eth.vids.get('0x12345') &lt;async&gt; getLikesContract() Get the contract instance of the likes contract Source: paratii.eth.vids.js Returns: Object representing the contract Type Promise Example let contract = await paratii.eth.vids.getLikesContract() &lt;async&gt; getVideoRegistry() Get the contract instance of the videos contract Source: paratii.eth.vids.js Returns: Object representing the contract Type Promise Example let contract = await paratii.eth.vids.getVideoRegistry() &lt;async&gt; getViewsContract() Get the contract instance of the views contract Source: paratii.eth.vids.js Returns: Object representing the contract Type Promise Example let contract = await paratii.eth.vids.getViewsContract() &lt;async&gt; like(videoId) Writes a like for the video on the blockchain (contract Likes), and negates a dislike for the video, if it exists. Parameters: Name Type Description videoId string univocal video identifier randomly generated Source: paratii.eth.vids.js Returns: transaction recording the like Type Promise Example let result = paratii.eth.vids.like('some-id') makeId() Creates a random id Source: paratii.eth.vids.js Returns: id created Type string Example let id = paratii.eth.vids.makeId() &lt;async&gt; sendLike(options) record a like/dislike to the video on the blockchain TODO RIVEDI I TIPI Parameters: Name Type Description options Object data about the video to like Properties Name Type Description videoId string univocal video id liked Boolean true/false Source: paratii.eth.vids.js Returns: transaction recording the like Type Promise Examples await paratii.eth.vids.sendLike({ videoId: 'some-id', liked: true }) await paratii.eth.vids.sendLike({ videoId: 'some-id', liked: false }) &lt;async&gt; update(videoId, options) Update the information on the video. Only the account that has registered the video, or the owner of the contract, can update the information. Parameters: Name Type Description videoId string univocal video identifier options Object key value pairs of properties and new values e.g. ({title: 'another-title'}) Source: paratii.eth.vids.js Returns: Updated video informations Type Promise Example paratii.eth.vids.update('some-video-id', {title: 'another-title'}) &lt;async&gt; userViewedVideo(options) Check if the viewer has already viewed the video Parameters: Name Type Description options Object data about the video and the viewer Properties Name Type Description viewer string viewer address videoId string univocal video identifier Source: paratii.eth.vids.js Returns: true if the current user already viewed the video, false otherwise Type Promise Example let result = await paratii.eth.vids.userViewedVideo({viewer:'some-user-id',videoId: 'some-video-id'}) &lt;async&gt; view(options) record a views to the video on the blockchain Parameters: Name Type Description options Object data about the video and the viewer Properties Name Type Description viewer string address of the viewer videoId string univocal video identifier randomly generated ipfsData string ipfs multihash Source: paratii.eth.vids.js Returns: transaction recording the view Type Promise Example await paratii.eth.vids.view({viewer:'some-user-id',videoId: 'some-video-id'}) Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiEthVouchers.html":{"id":"ParatiiEthVouchers.html","title":"Class: ParatiiEthVouchers","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiEthVouchers ParatiiEthVouchers Functions for redeeming vouchers new ParatiiEthVouchers(context) Parameters: Name Type Description context Object ParatiiEth instance Properties: Name Type Description eth ParatiiEth ParatiiEth instance Source: paratii.eth.vouchers.js Methods &lt;async&gt; create(options) Function for creating a voucher. Can only be called by the owner of the contract. Parameters: Name Type Description options Object data about the voucher Properties Name Type Description voucherCode string unique string associated to this voucher amount number amount of PTI in wei of this voucher Source: paratii.eth.vouchers.js Returns: the voucher id Type Promise Example await paratii.eth.vouchers.create({ voucherCode: 'some-id', amount: 10 }) &lt;async&gt; createVouchers(number, amount) Generates a given number of vouchers with unique IDs, and the given amount, and returns an array of objects. Parameters: Name Type Description number number number of voucher to create amount number amount of every voucher Source: paratii.eth.vouchers.js Returns: Object containing every voucher created Type Promise Example let vouchers = await paratii.eth.vouchers.createVouchers(10, 10) &lt;async&gt; getVouchersContract() Get the contract instance of the vouchers contract Source: paratii.eth.vouchers.js Returns: Object representing the contract Type Promise Example let contract = await paratii.eth.vids.getVouchersContract() &lt;async&gt; redeem(voucherCode) Function for redeeming a voucher to the current account's address. Parameters: Name Type Description voucherCode string univocal voucher code Source: paratii.eth.vouchers.js Returns: true if everything goes well, otherwise throws an error Type Promise Example await paratii.eth.vouchers.redeem('some-code') &lt;async&gt; test() throws a test error Source: paratii.eth.vouchers.js Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiIPFS.html":{"id":"ParatiiIPFS.html","title":"Class: ParatiiIPFS","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiIPFS ParatiiIPFS Contains functions to interact with the IPFS instance new ParatiiIPFS(config) Parameters: Name Type Description config ParatiiIPFSSchema configuration object to initialize Paratii object Properties: Name Type Description local ParatiiIPFSLocal operations on the local node remote ParatiiIPFSRemote operations on remote node Source: paratii.ipfs.js Methods &lt;async&gt; addAndPinJSON(data) adds a JSON structure to the local node and signals remote node to pin it Parameters: Name Type Description data object JSON object to store Source: paratii.ipfs.js Returns: returns ipfs multihash of the stored object. Type string Example let result = await paratiiIPFS.addAndPinJSON(data) addAndTranscode(files) adds a file to local IPFS node and signals transcoder to transcode it Parameters: Name Type Description files Array Array of HTML5 File Objects Source: paratii.ipfs.js Returns: An EventEmitter error(msg) log errors on the console if verbose is set Parameters: Name Type Argument Description msg string &lt;repeatable&gt; error message Source: paratii.ipfs.js Example paratii.ipfs.error(&quot;some-text&quot;) log(msg) log messages on the console if verbose is set Parameters: Name Type Argument Description msg string &lt;repeatable&gt; text to log Source: paratii.ipfs.js Example paratii.ipfs.log(&quot;some-text&quot;) start() Starts the IPFS node Source: paratii.ipfs.js Returns: that resolves in an IPFS instance Type Promise Example paratii.ipfs.start() stop() Stops the IPFS node. Source: paratii.ipfs.js Example paratii.ipfs.stop() warn(msg) log warns on the console if verbose is set Parameters: Name Type Argument Description msg string &lt;repeatable&gt; warn text Source: paratii.ipfs.js Example paratii.ipfs.warn(&quot;some-text&quot;) Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiIPFSLocal.html":{"id":"ParatiiIPFSLocal.html","title":"Class: ParatiiIPFSLocal","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiIPFSLocal ParatiiIPFSLocal IPFS UPLOADER : Paratii IPFS uploader interface. new ParatiiIPFSLocal(opts) Parameters: Name Type Description opts ParatiiIPFSUploaderSchema Source: paratii.ipfs.local.js Extends EventEmitter Methods add(file) uploads a single file to *local* IPFS node Parameters: Name Type Description file File HTML5 File Object. Source: paratii.ipfs.local.js Returns: checkout the upload function below for details. Type EventEmitter Example let uploaderEv = paratiiIPFS.uploader.add(files) addDirectory(dirPath) upload an entire directory to IPFS Parameters: Name Type Description dirPath string path to directory Source: paratii.ipfs.local.js Returns: returns the {multihash, path, size} for the uploaded folder. Type Promise Example ? &lt;async&gt; addJSON(data) adds a data Object to the IPFS local instance Parameters: Name Type Description data Object JSON object to store Source: paratii.ipfs.local.js Returns: promise that resolves as the ipfs multihash Type Promise Example let result = await paratii.ipfs.local.addJSON(data) &lt;async&gt; get(hash) get file from ipfs Parameters: Name Type Description hash string ipfs multihash of the file Source: paratii.ipfs.local.js Returns: the file (path,content) Type Promise Example let result = await paratiiIPFS.add(fileStream) let hash = result[0].hash let fileContent = await paratiiIPFS.get(hash) &lt;async&gt; getJSON(multihash) gets a JSON object stored in IPFS Parameters: Name Type Description multihash string ipfs multihash of the object Source: paratii.ipfs.local.js Returns: requested Object Type Promise Example let jsonObj = await paratii.ipfs.getJSON('some-multihash') upload(files) upload an Array of files as is to the local IPFS node Parameters: Name Type Description files Array HTML5 File Object Array. Source: paratii.ipfs.local.js Returns: returns EventEmitter with the following events: - 'start': uploader started. - 'progress': (chunkLength, progressPercent) - 'fileReady': (file) triggered when a file is uploaded locally. - 'done': (files) triggered when the uploader is done locally. - 'error': (err) triggered whenever an error occurs. Type EventEmitter Example paratii.ipfs.local.upload('path/to/file') TODO: this is not &quot;local&quot; only, it calls xhrupload in case we are dealing with an html5 file! Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiIPFSRemote.html":{"id":"ParatiiIPFSRemote.html","title":"Class: ParatiiIPFSRemote","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiIPFSRemote ParatiiIPFSRemote IPFS UPLOADER : Paratii IPFS uploader interface. new ParatiiIPFSRemote(opts) Parameters: Name Type Description opts ParatiiIPFSUploaderSchema Source: paratii.ipfs.remote.js Extends EventEmitter Methods pinFile(fileHash, options) Signal the remote node to pin a File Parameters: Name Type Description fileHash Object hash of the file to pin options Object [description] Source: paratii.ipfs.remote.js Returns: a Promise/EventEmitter that resolves inthe hash of the pinned file Type Promise Example paratii.ipfs.remote.pinFile('QmQP5SJzEBKy1uAGASDfEPqeFJ3HUbEp4eZzxvTLdZZYwB') xhrUpload(file, hash, ev) Upload a file over XHR to the transcoder. To be called with an event emitter as the last argument Parameters: Name Type Argument Description file Object file to upload hash string IPFS multi-hash of the file ev EventEmitter &lt;nullable&gt; optional event emitter Source: paratii.ipfs.remote.js Example this.xhrUpload(file, hashedFile) Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "},"ParatiiTranscoder.html":{"id":"ParatiiTranscoder.html","title":"Class: ParatiiTranscoder","body":" Paratii Classes ParatiiParatiiCoreUsersParatiiCoreVidsParatiiDbParatiiDbUsersParatiiDbVidsParatiiEthParatiiEthEventsParatiiEthTcrParatiiEthUsersParatiiEthVidsParatiiEthVouchersParatiiIPFSParatiiIPFSLocalParatiiIPFSRemoteParatiiTranscoder Global Global Class: ParatiiTranscoder ParatiiTranscoder IPFS UPLOADER : Paratii IPFS uploader interface. new ParatiiTranscoder(opts) Parameters: Name Type Description opts ParatiiIPFSUploaderSchema Source: paratii.transcoder.js Extends EventEmitter Methods addAndTranscode(files) convenience method for adding and transcoding files Parameters: Name Type Description files Array Array of HTML5 File Objects Source: paratii.transcoder.js getMetaData(fileHash, options) [getMetaData description] Parameters: Name Type Description fileHash Object [description] options Object [description] Source: paratii.transcoder.js Returns: [description] Type Object transcode(fileHash, options) signals transcoder(s) to transcode fileHash Parameters: Name Type Description fileHash string IPFS file hash. options Object ref: https://github.com/Paratii-Video/paratii-lib/blob/master/docs/paratii-ipfs.md#ipfsuploadertranscodefilehash-options Source: paratii.transcoder.js Returns: EventEmitter with the following events: - 'uploader:progress': (hash, chunkSize, percent) client to transcoder upload progress. - 'transcoding:started': (hash, author) - 'transcoding:progress': (hash, size, percent) - 'transcoding:downsample:ready' (hash, size) - 'transcoding:done': (hash, transcoderResult) triggered when the transcoder is done - returns the hash of the transcoded file - 'transcoder:error': (err) triggered whenever an error occurs. Type EvenEmitter Ã— Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-12T15:55:56+02:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
