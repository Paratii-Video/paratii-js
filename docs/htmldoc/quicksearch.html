<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"schemas.js.html":{"id":"schemas.js.html","title":"Source: schemas.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: schemas.js const joi = require('joi') /** * @typedef {Array} accountSchema * @property {?string} address * @property {?string} privateKey * @property {?string} mnemonic */ const accountSchema = joi.object({ address: joi.string().default(null).allow(null), privateKey: joi.string().default(null).allow(null), mnemonic: joi.string().default(null).allow(null) }).default() const ethSchema = joi.object({ provider: joi.string().default('ws://localhost:8546'), registryAddress: joi.string().default(null).allow(null), isTestNet: joi.boolean().optional() }).default() const ipfsSchema = joi.object({ repo: joi.string().default(null).allow(null), // passed to IPFS constructor as `config.Addresses.Swarm` swarm: joi .array() .ordered( joi.string().default('/dns4/star.paratii.video/tcp/443/wss/p2p-webrtc-star'), joi.string().default('/dns/ws.star.paratii.video/wss/p2p-websocket-star/') ), bootstrap: joi .array() .ordered( joi.string().default('/dns4/bootstrap.paratii.video/tcp/443/wss/ipfs/QmeUmy6UtuEs91TH6bKnfuU1Yvp63CkZJWm624MjBEBazW') ), 'bitswap.maxMessageSize': joi.number().default(256 * 1024), chunkSize: joi.number().default(128 * 1024), xhrChunkSize: joi.number().default(1 * 1024 * 1024), maxFileSize: joi.number().default(300 * 1024 * 1024), defaultTranscoder: joi.string().default('/dns4/bootstrap.paratii.video/tcp/443/wss/ipfs/QmeUmy6UtuEs91TH6bKnfuU1Yvp63CkZJWm624MjBEBazW'), transcoderDropUrl: joi.string().default('https://uploader.paratii.video/api/v1/transcode') }).default() const dbSchema = joi.object({ provider: joi.string().default('https://db.paratii.video/api/v1/') }).default() // this is the data structure of a video const videoSchema = joi.object({ id: joi.string().default(null), author: joi.string().empty('').default('').allow(null), description: joi.string().empty('').default(''), duration: joi.string().empty('').default('').allow(null), filename: joi.string().empty('').default('').allow(null).allow(''), filesize: joi.any(), free: joi.string().empty('').default(null).allow(null), ipfsHashOrig: joi.string().empty('').default(''), ipfsHash: joi.string().empty('').default(''), owner: joi.string().required(), price: joi.any().default(0), // published: joi.any().default(false).allow(null), title: joi.string().empty('').default(''), thumbnails: joi.array(), storageStatus: joi.object({ name: joi.string().required(), data: joi.object().allow(null) }).optional().default({}), transcodingStatus: joi.object({ name: joi.string().required(), data: joi.object().allow(null) }).allow(null).default({}), uploadStatus: joi.object({ name: joi.string().required(), data: joi.object().allow(null) }).allow(null).default({}) }) export { accountSchema, ethSchema, ipfsSchema, dbSchema, videoSchema } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.js.html":{"id":"paratii.js.html","title":"Source: paratii.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.js import { ParatiiCore } from './paratii.core.js' import { ParatiiDb } from './paratii.db.js' import { ParatiiEth } from './paratii.eth.js' import { ParatiiIPFS } from './paratii.ipfs.js' import { ipfsSchema, ethSchema, accountSchema, dbSchema } from './schemas.js' const joi = require('joi') const utils = require('./utils.js') // /** * Paratii library main object * The Paratii object serves as the general entry point for interacting with the family of Paratii * contracts that are deployed on the blockchain, utilities to run and interact with a local IPFS node, * and utilities to interact with the Paratii index. * @class Paratii * @param {accountSchema} opts options object to configure paratii library * @param {String} opts.provider optional - the address of an ethereum node (defaults to localhost:8754) * @param {String} opts.registryAddress optional - the address where the Paratii Contract registry can be found * @param {String} opts.address optional - address of the operator/user * @param {String} opts.privateKey optional - private key of the user * @param {Object} opts.ipfs TODO fix ipfs.repo --&gt; ipfsrepo * @param {String} opts.ipfs.repo optional - namespace of the ipfs repository * @param {Object} opts.db TODO fix db.provider --&gt; dbprovider * @param {String} opts.db.provider optional - baseURL of the mongoDb mirror * @param {String} opts.mnemonic optional - mnemonic of the user * * @example paratii = new Paratii({ 'eth.provider': 'http://localhost:8545', address: 'some-user-id', privateKey: 'some-user-priv-key'}) * @class paratii */ class Paratii { constructor (opts = {}) { const schema = joi.object({ account: accountSchema, eth: ethSchema, db: dbSchema, ipfs: ipfsSchema }) const result = joi.validate(opts, schema) if (result.error) throw result.error this.config = result.value this.config.paratii = this this.eth = new ParatiiEth(this.config) this.core = new ParatiiCore(this.config) this.db = new ParatiiDb(this.config) this.ipfs = new ParatiiIPFS(this.config) } /** * Set the ethereum address what will be used to sign all transactions * @param {String} address address of the operator/user * @param {String} privateKey optional - private key of the operator/user * @example paratii.setAccount('some-user-id','some-user-pub-key') * @memberof paratii */ setAccount (address, privateKey) { this.eth.setAccount(address, privateKey) } /** * Set the address of the ParatiiRegistry contract * @param {String} address address of the ParatiiRegistry contract * @example paratii.setRegistryAddress('some-address') * @memberof paratii */ setRegistryAddress (address) { return this.eth.setRegistryAddress(address) } /** * return an array of strings with diagnostic info * @return {Promise} array of strings with diagnostic info * @example paratii.diagnose() * @memberof paratii */ async diagnose () { let msg, address, msgs let isOk = true msgs = [] function log (msg) { msgs.push(msg) } log('Paratii was initialized with the following options:') log(this.config) log('Checking main account') if (this.config.account.address &amp;&amp; this.config.account.privateKey) { log(`Your private key: ${this.config.account.privateKey}`) log(`Your private key: ${this.config.account.privateKey}`) log(`First wallet account: ${this.eth.web3.eth.accounts.wallet[0].address}`) } address = this.eth.getRegistryAddress() if (!address) { log('*** No registry address found!') log(`Value of this.config['eth.registryAddress']: ${this.config['eth.registryAddress']}`) isOk = false } else { log('checking deployed code of Registry...') msg = await this.eth.web3.eth.getCode(address) if (msg === '0x') { log(`ERROR: no code was found on the registry address ${address}`) log(msg) } else { log('... seems ok...') // log(`We found the following code on the registry address ${address}`) // log(msg) } log(`checking for addresses on registry@${address}`) let registry = await this.eth.getContract('Registry') log(`(registry address is ${registry.options.address})`) for (var name in this.eth.contracts) { if (name !== 'Registry') { address = await registry.methods.getContract(name).call() log(`address of ${name}: ${address}`) } } } if (isOk) { log('---- everything seems fine -----') } else { log('***** Something is wrong *****') } return msgs } } export default Paratii export { Paratii, utils, ParatiiIPFS, ParatiiDb, ParatiiEth } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.core.js.html":{"id":"paratii.core.js.html","title":"Source: paratii.core.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.core.js import { ParatiiCoreVids } from './paratii.core.vids.js' import { ParatiiCoreUsers } from './paratii.core.users.js' import { ipfsSchema, ethSchema, accountSchema, dbSchema } from './schemas.js' import joi from 'joi' /** * Contains functions that operate transversally over several backend systems. &lt;br /&gt; * validates the config file and istantiates ParatiiCoreVids and ParatiiCoreUsers. * @param {Object} config configuration object to initialize Paratii object * @class paratii.core * @memberof paratii */ export class ParatiiCore { constructor (config) { const schema = joi.object({ account: accountSchema, eth: ethSchema, db: dbSchema, ipfs: ipfsSchema, paratii: joi.object().optional() }) const result = joi.validate(config, schema) if (result.error) throw result.error this.config = config // this.config = result.value this.vids = new ParatiiCoreVids(this.config) this.users = new ParatiiCoreUsers(this.config) this.paratii = this.config.paratii } /** * migrate all contract data for paratii.config.account to a new account * @memberof paratii.core */ async migrateAccount (newAccount) { // migrate the videos const oldAccount = this.config.account.address const vids = await this.vids.search({owner: oldAccount}) for (let i in vids) { let vid = vids[i] await this.vids.update(vid.id, {owner: newAccount}) await this.paratii.eth.tcr.exit(vid.id) } // transfer all PTI to the new account let ptiBalance = await this.paratii.eth.balanceOf(oldAccount, 'PTI') console.log(ptiBalance) await this.paratii.eth.transfer(newAccount, ptiBalance, 'PTI') // FIXME: need to call tc.apply(vid.id) with newAccount as sender (how to do that?) } } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.core.users.js.html":{"id":"paratii.core.users.js.html","title":"Source: paratii.core.users.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.core.users.js const joi = require('joi') /** * Utilities to create and manipulate information about the users on the blockchain. * @param {Object} config configuration object to initialize Paratii object * @class paratii.core.users */ export class ParatiiCoreUsers { constructor (config) { const schema = joi.object({ 'db.provider': joi.string().default(null) }).unknown() const result = joi.validate(config, schema) const error = result.error if (error) throw error this.config = result.value this.paratii = this.config.paratii } /** * Creates a user, fields id, name and email go to the smart contract Users, other fields are stored on IPFS. * @param {Object} options information about the video ( id, name, email ... ) * @return {Promise} the id of the newly created user * @example * paratii.core.users.create({ * id: 'some-user-id', * name: 'A user name', * email: 'some@email.com', * ... * }) * @memberof paratii.core.users */ async create (options) { let keysForBlockchain = ['id', 'name', 'email'] let optionsKeys = Object.keys(options) let optionsBlockchain = {} let optionsIpfs = {} optionsKeys.forEach(function (key) { if (keysForBlockchain.includes(key)) { optionsBlockchain[key] = options[key] } else { optionsIpfs[key] = options[key] } }) let hash = await this.paratii.ipfs.addJSON(optionsIpfs) optionsBlockchain['ipfsData'] = hash return this.paratii.eth.users.create(optionsBlockchain) } /** * retrieve data about the user * @param {String} id user univocal id * @return {Object} data about the user * @example paratii.core.users.get('some-user-id') * @memberof paratii.core.users */ get (id) { return this.paratii.db.users.get(id) } /** * Updates a user's details. name and email are defined in the smart contract Users, other fields get written to IPFS. * @param {String} userId user univocal id * @param {Object} options updated data i.e. { name: 'A new user name' } * @return {Promise} updated data about the user * @example paratii.core.users.update('some-user-id', {name: 'A new user name'}) * @memberof paratii.core.users */ async update (userId, options) { const schema = joi.object({ name: joi.string().default(null), email: joi.string().default(null) }) const result = joi.validate(options, schema) const error = result.error if (error) throw error options = result.value let data = await this.get(userId) for (let key in options) { if (options[key] !== null) { data[key] = options[key] } } data['id'] = userId await this.create(data) return data } } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.core.vids.js.html":{"id":"paratii.core.vids.js.html","title":"Source: paratii.core.vids.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.core.vids.js import { videoSchema } from './schemas.js' import joi from 'joi' /** * Utilities to create and manipulate information about the videos on the blockchain. * @param {Object} config configuration object to initialize Paratii object * @class paratii.core.vids */ export class ParatiiCoreVids { constructor (config) { // const schema = joi.object({ // 'db.provider': joi.string().default(null) // }).unknown() // // const result = joi.validate(config, schema) // const error = result.error // if (error) throw error // let options = result.value this.config = config this.paratii = this.config.paratii } /** * Writes a like for the video on the blockchain (contract Likes), and negates a dislike for the video, if it exists. * @param {String} videoId univocal video identifier * @return {Object} information about the transaction recording the like * @example paratii.core.vids.like('some-video-id') * @memberof paratii.core.vids */ like (videoId) { return this.paratii.eth.vids.like(videoId) } /** * Writes a dislike for the video on the blockchain (contract Likes), and negates a like for the video, if it exists. * @param {String} videoId univocal video identifier * @return {Object} information about the transaction recording the dislike * @example paratii.core.vids.dislike('some-video-id') * @memberof paratii.core.vids */ dislike (videoId) { return this.paratii.eth.vids.dislike(videoId) } /** * Check if the current user has already liked the video * @param {String} videoId univocal video identifier * @return {Boolean} true if the current user already liked the video, false otherwise * @example paratii.core.vids.doesLike('some-video-id') * @memberof paratii.core.vids */ doesLike (videoId) { return this.paratii.eth.vids.doesLike(videoId) } /** * Check if the viewer has already viewed the video * @param {String} viewer viewer address * @param {String} videoId univocal video identifier * @return {Boolean} true if the current user already viewed the video, false otherwise * @example paratii.core.vids.hasViewedVideo('some-user-id','some-video-id') * @memberof paratii.core.vids */ hasViewedVideo (viewer, videoId) { return this.paratii.eth.vids.userViewedVideo({ viewer: viewer, videoId: videoId }) } /** * Check if the current user has already disliked the video * @param {String} videoId univocal video identifier * @return {Boolean} true if the current user already disliked the video, false otherwise * @example paratii.core.vids.doesDislike('some-video-id') * @memberof paratii.core.vids */ doesDislike (videoId) { return this.paratii.eth.vids.doesDislike(videoId) } /** * This call will register the video on the blockchain, add its metadata to IPFS, upload file to IPFS, and transcode it * @param {Object} options information about the video ( id, title, FilePath ... ) * @return {Promise} information about the video ( id, owner, ipfsHash ... ) * @example paratii.core.vids.create({ * id: 'some-video-id', * owner: 'some-user-id', * title: 'some Title', * author: 'Steven Spielberg', * duration: '2h 32m', * description: 'A long description', * price: 0, * file: 'test/data/some-file.txt' * }) * @memberof paratii.core.vids */ async create (options = {}) { const result = joi.validate(options, videoSchema) const error = result.error if (error) throw error options = result.value if (options.id === null) { options.id = this.paratii.eth.vids.makeId() } let hash = await this.paratii.ipfs.addAndPinJSON({ author: options.author, description: options.description, duration: options.duration, filename: options.filename, filesize: options.filesize, free: options.free, storageStatus: options.storageStatus, title: options.title, transcodingStatus: options.transcodingStatus, uploadStatus: options.uploadStatus, thumbnails: options.thumbnails }) options.ipfsData = hash await this.paratii.eth.vids.create({ id: options.id, owner: options.owner, price: options.price, ipfsHashOrig: options.ipfsHashOrig, ipfsHash: options.ipfsHash, ipfsData: options.ipfsData }) return options } /** * Update the information on the video. * Only the account that has registered the video, or the owner of the contract, can update the information. * @param {String} videoId univocal video identifier * @param {Object} options key value pairs of properties and new values e.g. ({title: 'another-title'}) * @param {Object} dataToUpdate optional. old data of the video. If not passed to the method, it will fetch the data itself using the videoId * @return {Promise} Updated video informations * @example paratii.core.vids.update('some-video-id', {title: 'another-title'}) * @memberof paratii.core.vids */ async update (videoId, options, dataToUpdate) { let data if (dataToUpdate) { data = dataToUpdate } else { data = await this.get(videoId) } if (data === null) { throw new Error('No video to update') } // FIXME: missing the validate invociation const elements = videoSchema._inner.children let dataToSave = {} elements.forEach(function (name) { const key = name.key if (options[key] !== undefined) { dataToSave[key] = options[key] } else { dataToSave[key] = data[key] } }) await this.create(dataToSave) return dataToSave } /** * Update the information of the video the video already exists, otherwise it creates it * @param {Object} options video informations * @return {Promise} updated/new video informations * @example * paratii.core.vids.upsert({ id: 'some-video-id', owner: 'some-user-id', title: 'videoTitle'}) //insert a new video * @memberof paratii.core.vids */ async upsert (options) { let data = null if (options.id) { data = await this.get(options.id) } if (!data) { return this.create(options) } else { return this.update(options.id, options, data) } } /** * Register a view on the blockchain * @param {Object} options should contain keys viewer (address of the viewer) and videoId (univocal video identifier) * @return {Promise} information about the transaction recording the view * @example paratii.core.vids.view({viewer:'some-user-id',videoId: 'some-video-id'}) * @memberof paratii.core.vids */ async view (options) { let keysForBlockchain = ['viewer', 'videoId'] let optionsKeys = Object.keys(options) let optionsBlockchain = {} let optionsIpfs = {} optionsKeys.forEach(function (key) { if (keysForBlockchain.includes(key)) { optionsBlockchain[key] = options[key] } else { optionsIpfs[key] = options[key] } }) let hash = await this.paratii.ipfs.addJSON(optionsIpfs) optionsBlockchain['ipfsData'] = hash return this.paratii.eth.vids.view(optionsBlockchain) } /** * Get the data of the video identified by videoId * @param {String} videoId univocal video identifier * @return {Promise} data about the video * @example paratii.core.vids.get('some-video-id') * @memberof paratii.core.vids */ async get (videoId) { return this.paratii.db.vids.get(videoId) } /** * Get the data of the video * @param {Object} options data about the video and (optional) owner i.e {'keyword':'titleOfTheVideo'} * @return {Promise} data about the video * @example paratii.core.vids.search({keyword : 'titleOftheVideo'}) * the keyword value can be one from the following list * - video title * - description * - owner * - uploader.name * - uploader.address * - tags * @memberof paratii.core.vids */ search (options) { return this.paratii.db.vids.search(options) } } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.db.js.html":{"id":"paratii.db.js.html","title":"Source: paratii.db.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.db.js import { ParatiiDbVids } from './paratii.db.vids.js' import { ParatiiDbUsers } from './paratii.db.users.js' import { dbSchema, accountSchema } from './schemas.js' import joi from 'joi' /** * ParatiiDb contains a functionality to interact with the Paratii Blockchain Index. &lt;br&gt; * validates the config file and istantiates ParatiiDbVids and ParatiiDbUsers. * @param {Object} config * @class paratii.db * @memberof paratii */ export class ParatiiDb { constructor (config) { const schema = { db: dbSchema, account: accountSchema } const result = joi.validate(config, schema, {allowUnknown: true}) if (result.error) throw result.error this.config = config this.config.db = result.value.db this.config.account = result.value.account this.vids = new ParatiiDbVids(this.config) this.users = new ParatiiDbUsers(this.config) } } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.db.users.js.html":{"id":"paratii.db.users.js.html","title":"Source: paratii.db.users.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.db.users.js const fetch = require('isomorphic-fetch') /** * ParatiiDbUsers contains functionalities regarding the users to interact with the Paratii Blockchain Index * @param {Object} config object to initialize Paratii object * @class paratii.db.users */ export class ParatiiDbUsers { constructor (config) { this.config = config this.apiUsers = 'users/' this.apiVideos = '/videos' } /** * retrieve data about the user * @param {String} userId user univocal id * @return {Promise} data about the user * @example paratii.db.users.get('some-user-id') * @memberof paratii.db.users */ async get (userId) { let users = await fetch(this.config.db.provider + this.apiUsers + userId, { method: 'get' }).then(function (response) { return response.json() }) return users } /** * get information about all the videos of the user * @param {String} userId univocal user identifier * @return {Promise} Collection of all the videos of the user * @example paratii.db.users.videos('some-user-id') * @memberof paratii.db.users */ async videos (userId) { let users = await fetch(this.config.db.provider + this.apiVersion + this.apiUsers + userId + this.apiVideos, { method: 'get' }).then(function (response) { return response.json() }) console.log(users) return users } } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.db.vids.js.html":{"id":"paratii.db.vids.js.html","title":"Source: paratii.db.vids.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.db.vids.js const joi = require('joi') const fetch = require('isomorphic-fetch') /** * ParatiiDbUsers contains functionalities regarding the videos to interact with the Paratii Blockchain Index * @param {Object} config object to initialize Paratii object * @class paratii.db.vids */ export class ParatiiDbVids { constructor (config) { this.config = config this.apiVideos = 'videos/' } /** * Get information about this video from the db * @param {String} videoId univocal video identifier * @return {Promise} data about the video * @example paratii.db.vids.get('some-video-id') * @memberof paratii.db.vids */ async get (videoId) { let videos = await fetch(this.config.db.provider + this.apiVideos + videoId, { method: 'get' }).then(function (response) { return response.json() }) return videos } /** * Get the data of the video * @param {Object} options data about the video and (optional) owner i.e {'keyword':'titleOfTheVideo'} * @return {Promise} data about the video * @example paratii.db.vids.search({keyword : 'titleOftheVideo'}) * the keyword value can be one from the following list * - video title * - description * - owner * - uploader.name * - uploader.address * - tags * @memberof paratii.db.vids */ async search (options) { // FIXME: does not handle combinations of parameters yet const schema = joi.object({ 'owner': joi.string().empty(), 'keyword': joi.string().empty() }) const result = joi.validate(options, schema) const error = result.error if (error) throw error let k = '' for (let keyword in options) { k = `${keyword}=${options[keyword]}` } if (k !== '') { k = `?${k}` } let videos = await fetch(this.config.db.provider + this.apiVideos + k, { method: 'get' }).then(function (response) { return response.json() }) return videos } } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.eth.js.html":{"id":"paratii.eth.js.html","title":"Source: paratii.eth.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.eth.js import { add0x } from './utils.js' import { ParatiiEthVids } from './paratii.eth.vids.js' import { ParatiiEthUsers } from './paratii.eth.users.js' import { ParatiiEthEvents } from './paratii.eth.events.js' import { ParatiiEthVouchers } from './paratii.eth.vouchers.js' import { ParatiiEthTcr } from './paratii.eth.tcr.js' import { patchWallet } from './paratii.eth.wallet.js' import { ethSchema, accountSchema } from './schemas.js' import joi from 'joi' const Web3 = require('web3') // const joi = require('joi') /** * contains functions to interact with the Ethereum blockchain and the Paratii contracts deployed there. * @param {Object} config configuration object to initialize Paratii object * @class paratii.eth * @memberof paratii */ export class ParatiiEth { constructor (config) { const schema = joi.object({ account: accountSchema, eth: ethSchema // web3: joi.any().default(null) }) const result = joi.validate(config, schema, {allowUnknown: true}) if (result.error) throw result.error config.eth = result.value.eth config.account = result.value.account if (config.eth.provider.match(/(localhost|127\\.0\\.0\\.1)/g)) { config.eth.isTestNet = true } else { config.eth.isTestNet = false } if (config.web3) { this.web3 = config.web3 } else { this.web3 = new Web3() if (config.eth.provider.substring(0, 2) === 'ws') { this.web3.setProvider(new this.web3.providers.WebsocketProvider(config.eth.provider)) } else { this.web3.setProvider(new this.web3.providers.HttpProvider(config.eth.provider)) } } this.config = config this.wallet = patchWallet(this.web3.eth.accounts.wallet, this.config) this.setAccount(this.config.account.address, this.config.account.privateKey, this.config.account.mnemonic) this.contracts = {} this.contracts.ParatiiToken = this.requireContract('ParatiiToken') this.contracts.Avatar = this.requireContract('Avatar') this.contracts.Registry = this.requireContract('Registry') this.contracts.SendEther = this.requireContract('SendEther') this.contracts.Users = this.requireContract('Users') this.contracts.Videos = this.requireContract('Videos') this.contracts.Store = this.requireContract('Store') this.contracts.Likes = this.requireContract('Likes') this.contracts.Views = this.requireContract('Views') this.contracts.Vouchers = this.requireContract('Vouchers') this.contracts.TcrPlaceholder = this.requireContract('TcrPlaceholder') this.vids = new ParatiiEthVids(this) this.users = new ParatiiEthUsers(this) this.events = new ParatiiEthEvents(this) this.vouchers = new ParatiiEthVouchers(this) this.tcr = new ParatiiEthTcr(this) } /** * creates an account using the private key or, if not present, using the mnemonic * @param {String} address public address * @param {String} privateKey private key related to the previous public address * @param {String} mnemonic mnemonic related to the previous public address * @example paratii.eth.setAccount('some-address','some-private-key') * @example paratii.eth.setAccount('some-address','some-mnemonic') * @memberof paratii.eth */ setAccount (address, privateKey, mnemonic) { const wallet = this.web3.eth.accounts.wallet this.config.account.address = address this.config.account.privateKey = privateKey this.web3.eth.testAccount = address if (privateKey) { let account = wallet.add(privateKey) if (account.address !== address) { throw Error('Private Key and Account address are not compatible!') } this.config.account.address = address this.config.account.privateKey = privateKey } else if (mnemonic) { wallet.create(1, mnemonic) if (address &amp;&amp; wallet[0].address !== address) { throw Error(`Mnemonic ${mnemonic} and account address ${address} are not compatible!`) } this.config.account.address = wallet[0].address this.config.account.privateKey = wallet[0].privateKey } } /** * Get the contract instance specified * @param {String} name the name of the token * @return {Promise} Object representing the contract * @example paratii.eth.getContract('ParatiiToken') * @memberof paratii.eth */ async getContract (name) { let contract = this.contracts[name] if (!contract) { throw Error(`No contract with name &quot;${name}&quot; is known`) } if (!contract.options.address) { let address = await this.getContractAddress(name) if (address &amp;&amp; address !== '0x0') { contract.options.address = address } } if (!contract.methods.constructor._ethAccounts) { contract.methods.constructor._ethAccounts = this.web3.eth.accounts } contract.options.from = this.config.account.address return contract } /** * creates the javascript contract object from the json file * @param {String} contractName name of the contract * @return {String} Contract Object * @example paratii.eth.requireContract('ParatiiToken') * @memberof paratii.eth */ requireContract (contractName) { const artifact = require(`paratii-contracts/build/contracts/${contractName}.json`) let from = this.config.account.address const contract = new this.web3.eth.Contract( artifact.abi, { from: from, gas: this.web3.utils.toHex(4e6), data: artifact.bytecode }) // contract.setProvider(this.web3.currentProvider, this.web3.eth.accounts) return contract } /** * deploys contract on the blockchain * @param {String} name name of the contract * @param {Object} args configuration for the contract (strings or numbers). It is allowed to pass more than one parameter * @return {Promise} the deployed contract * @example paratii.eth.deployContract('ParatiiToken') * @memberof paratii.eth */ async deployContract (name, ...args) { if (!this.config.account.address) { let msg = 'You need an Ethereum account to write information to the blockchain - you can use .setAccount(address, [privateKey]) or specify it when creating the object' throw Error(msg) } let contract = await this.getContract(name) let deployedContract = await contract.deploy({arguments: args}).send() deployedContract.setProvider(this.web3.currentProvider, this.web3.eth.accounts) this.contracts[name] = deployedContract return deployedContract } /** * deploy all the contracts on the blockchain * @return {Promise} all the paratii contracts * @example let contracts = await paratii.eth.deployContracts() * @example let likes = await this.deployContract('Likes', paratiiRegistryAddress) * @memberof paratii.eth */ async deployContracts () { let paratiiRegistry = await this.deployContract('Registry') let paratiiRegistryAddress = paratiiRegistry.options.address await this.setRegistryAddress(paratiiRegistry.options.address) let paratiiAvatar = await this.deployContract('Avatar', paratiiRegistryAddress) let paratiiToken = await this.deployContract('ParatiiToken') let sendEther = await this.deployContract('SendEther') let userRegistry = await this.deployContract('Users', paratiiRegistryAddress) let videoRegistry = await this.deployContract('Videos', paratiiRegistryAddress) let videoStore = await this.deployContract('Store', paratiiRegistryAddress) let likes = await this.deployContract('Likes', paratiiRegistryAddress) let views = await this.deployContract('Views', paratiiRegistryAddress) let vouchers = await this.deployContract('Vouchers', paratiiRegistryAddress) let tcrPlaceholder = await this.deployContract('TcrPlaceholder', paratiiRegistryAddress, paratiiToken.options.address, this.web3.utils.toWei('5'), 100) paratiiRegistry = await this.getContract('Registry') await paratiiRegistry.methods.registerAddress('Avatar', paratiiAvatar.options.address).send() // console.log(`Registered address of Avatar ${paratiiAvatar.options.address} at contract ${paratiiRegistryAddress}`) await paratiiRegistry.methods.registerAddress('ParatiiToken', paratiiToken.options.address).send() await paratiiRegistry.methods.registerAddress('SendEther', sendEther.options.address).send() await paratiiRegistry.methods.registerAddress('Videos', videoRegistry.options.address).send() await paratiiRegistry.methods.registerAddress('Store', videoStore.options.address).send() await paratiiRegistry.methods.registerAddress('Users', userRegistry.options.address).send() await paratiiRegistry.methods.registerAddress('Likes', likes.options.address).send() await paratiiRegistry.methods.registerAddress('Views', views.options.address).send() await paratiiRegistry.methods.registerAddress('Vouchers', vouchers.options.address).send() await paratiiRegistry.methods.registerAddress('TcrPlaceholder', tcrPlaceholder.options.address).send() await paratiiRegistry.methods.registerUint('VideoRedistributionPoolShare', this.web3.utils.toWei('0.3')) await paratiiAvatar.methods.addToWhitelist(videoStore.address) this.contracts = { Avatar: paratiiAvatar, Registry: paratiiRegistry, ParatiiToken: paratiiToken, SendEther: sendEther, Users: userRegistry, Videos: videoRegistry, Likes: likes, Views: views, Vouchers: vouchers, Store: videoStore, TcrPlaceholder: tcrPlaceholder } // await this.setContractsProvider() this.setRegistryAddress(paratiiRegistryAddress) return this.contracts } /** * Set the provider on all the contracts * @example paratii.eth.setContractsProvider() * @memberof paratii.eth */ async setContractsProvider () { for (var key in this.contracts) { this.contracts[key].setProvider(this.web3.currentProvider, this.web3.eth.accounts) } } /** * return all the contracts * @return {Promise} all the contracts * @example let contracts = await paratii.eth.getContracts() * @memberof paratii.eth */ async getContracts () { for (var name in this.contracts) { let contract = this.contracts[name] if (!contract.options.address) { let address = await this.getContractAddress(name) if (address &amp;&amp; address !== '0x0') { contract.options.address = address } } } return this.contracts } /** * get the address of the contract on the blockchain * @param {String} name name of the contract * @return {Promise} Contract address on the blockchain (String) * @example paratii.eth.getContractAddress('ParatiiToken') * @memberof paratii.eth */ async getContractAddress (name) { let registryAddress = this.getRegistryAddress() if (name === 'Registry') { return registryAddress } if (!registryAddress) { throw Error('No registry address configured') } try { let registry = await this.getContract('Registry') if (!registry) { throw Error('No registry contract!') } let address = await registry.methods.getContract(name).call() return address } catch (err) { throw err } } /** * get the address of the Registry contract on the blockchain * @return {String} address on the blockchain * @example let registryAddress = paratii.eth.getRegistryAddress() * @memberof paratii.eth */ getRegistryAddress () { return this.config.eth.registryAddress } /** * set the address of the Registry contract on the blockchain * @param {String} registryAddress new address * @example await paratii.eth.setRegistryAddress('some-address') * @memberof paratii.eth */ setRegistryAddress (registryAddress) { this.config.eth.registryAddress = registryAddress for (var name in this.contracts) { let contract = this.contracts[name] contract.options.address = undefined } } /** * When called with a second argument, returns the balance of that Token.&lt;br&gt; * When called without a second argument, returns information about all relevant balances. * @param {String} address ethereum address * @param {String} symbol optional - symbol of the token (ETH,PTI) * @return {Promise} information about balances of that address * @example paratii.eth.balanceOf('some-address', 'ETH') // returns the ETH balance of the given address * @example paratii.eth.balanceOf('some-address', 'PTI') // returns the PTI balance of the given address * @example paratii.eth.balanceOf('some-address') // returns both the PTI and the ETH balance of the given address * @memberof paratii.eth */ async balanceOf (address, symbol) { let balance let balances = {} if (symbol &amp;&amp; !(['PTI', 'ETH'].includes(symbol))) { throw Error(`Unknown symbol &quot;${symbol}&quot;, must be one of &quot;ETH&quot;, &quot;PTI&quot;`) } if (!symbol || symbol === 'ETH') { balance = await this.web3.eth.getBalance(address) balances.ETH = balance } if (!symbol || symbol === 'PTI') { let contract = await this.getContract('ParatiiToken') balance = await contract.methods.balanceOf(address).call() balances.PTI = balance } if (symbol) { return balance } else { return balances } } /** * send ETH from current account to beneficiary * @param {String} beneficiary ETH address * @param {Number} amount amount of ETH to be sent * @param {String} description optional - description of the transaction (will be written in the blockchain) * @return {Promise} information about the transaction recording the transfer * @example return paratii.eth._transferETH('some-address', 20, 'an-optional-description') * @memberof paratii.eth */ async _transferETH (beneficiary, amount, description) { const contract = await this.getContract('SendEther') if (!contract.options || !contract.options.address) { throw Error('No SendEther contract known - please run paratii.diagnose()') } let from = this.config.account.address if (!from) { throw Error('No account set! Cannot send transactions') } if (!description) { description = '' } from = add0x(from) beneficiary = add0x(beneficiary) try { return await contract.methods.transfer(beneficiary, description).send({value: amount}) } catch (err) { throw err } } /** * send PTI from current account to beneficiary * @param {String} beneficiary ETH address * @param {Number} amount amount of PTI to be sent * @return {Promise} information about the transaction recording the transfer * @example return paratii.eth._transferPTI('some-address', 20) * @memberof paratii.eth */ async _transferPTI (beneficiary, amount) { const contract = await this.getContract('ParatiiToken') if (!contract.options || !contract.options.address) { throw Error('No ParatiiToken contract known - please run paratii.diagnose()') } let from = this.config.account.address if (!from) { throw Error('No account set! Cannot send transactions') } from = add0x(from) beneficiary = add0x(beneficiary) let result = await contract.methods.transfer(beneficiary, amount).send() return result } /** * Use this to send ETH or PTI from paratii.config.address * @param {String} beneficiary ETH address * @param {Number} amount amount of ETH/PTI to be sent * @param {String} symbol symbol of the token to send (ETH,PTI) * @param {String} description optional - description to be inserted in the blockchain * @return {Promise} information about the transaction recording the transfer * @example let result = await paratii.eth.transfer('some-address', 20, 'ETH', 'thanks for all the fish') * @memberof paratii.eth */ async transfer (beneficiary, amount, symbol, description) { if (symbol === 'ETH') { return this._transferETH(beneficiary, amount, description) } else if (symbol === 'PTI') { return this._transferPTI(beneficiary, amount) } } } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.eth.events.js.html":{"id":"paratii.eth.events.js.html","title":"Source: paratii.eth.events.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.eth.events.js /** * eth.events implements a part of the API of the EventEmitter, that can be used to manage subscriptions to Ethereum events. * @class paratii.eth.events */ export class ParatiiEthEvents { constructor (config) { this.config = config this._subscriptions = {} this.subscribe = config.web3.eth.subscribe this._customEvents = { TransferPTI: { contract: 'ParatiiToken', event: 'Transfer' }, TransferETH: { contract: 'SendEther', event: 'LogSendEther' }, CreateVideo: { contract: 'Videos', event: 'LogCreateVideo' }, UpdateVideo: { contract: 'Videos', event: 'LogCreateVideo' }, RemoveVideo: { contract: 'Videos', event: 'LogRemoveVideo' }, BuyVideo: { contract: 'Store', event: 'LogBuyVideo' }, CreateUser: { contract: 'Users', event: 'LogCreateUser' }, RemoveUser: { contract: 'Users', event: 'LogRemoveUser' }, CreateVoucher: { contract: 'Vouchers', event: 'LogCreateVoucher' }, RemoveVoucher: { contract: 'Vouchers', event: 'LogRemoveVoucher' }, RedeemVoucher: { contract: 'Vouchers', event: 'LogRedeemVoucher' }, Application: { contract: 'TcrPlaceholder', event: '_Application' }, NewVideoWhitelisted: { contract: 'TcrPlaceholder', event: '_NewVideoWhitelisted' } } } /** * parse event from simple string to an object * @param {String} eventType Event type * @return {Object} Event Object * @example let structuredEvent = this._getStructuredEvent('some-event') * @memberof paratii.eth.events */ _getStructuredEvent (eventType) { let structuredEvent = {} if (eventType.substr(eventType.length - 5).toLowerCase().indexOf('error') !== -1) { // error event structuredEvent.event = eventType.substr(0, eventType.length - 5) structuredEvent.emit = 'error' } else if (eventType.substr(eventType.length - 7).toLowerCase().indexOf('changed') !== -1) { // changed event structuredEvent.event = eventType.substr(0, eventType.length - 7) structuredEvent.emit = 'changed' } else { // data event structuredEvent.event = eventType structuredEvent.emit = 'data' } return structuredEvent } /** * subscribe to the specified event * @param {String} eventType type of the event * @param {Function} options function called when the events occurs * @param {?} listener optional ? * @return {Promise} [description] * @memberof paratii.eth.events */ async addListener (eventType, options, listener) { if (this._isFunction(options)) { return this._addListener(eventType, options) } else { return this._addListener(eventType, listener, options) } } /** * [_addListener description] * TODO RIVEDI I TIPI * @param {Object} eventType [description] * @param {Object} listener [description] * @param {Object} options [description] * @return {Promise} [description] * @memberof paratii.eth.events */ async _addListener (eventType, listener, options) { let structuredEvent = this._getStructuredEvent(eventType) let subscription = null switch (structuredEvent.event) { case 'newBlockHeaders': case 'syncing': case 'pendingTransactions': { subscription = await this.subscribe(eventType) subscription.on(structuredEvent.emit, listener) break } case 'logs': { if (options === undefined) { options = { fromBlock: null, topics: null } } subscription = this.subscribe('logs', options) subscription.on(structuredEvent.emit, listener) break } default: { let contract = await this.config.getContract(this._customEvents[structuredEvent.event].contract) subscription = await contract.events[this._customEvents[structuredEvent.event].event](options) subscription.on(structuredEvent.emit, listener) } } return this.addSubscription(eventType, subscription) } /** * [_isFunction description] * TODO RIVEDI I TIPI * @param {Object} functionToCheck [description] * @return {Boolean} [description] * @memberof paratii.eth.events */ _isFunction (functionToCheck) { var getType = {} return functionToCheck &amp;&amp; getType.toString.call(functionToCheck) === '[object Function]' } /** * [addSubscription description] * TODO RIVEDI I TIPI * @param {Object} eventType [description] * @param {Object} subscription [description] * @memberof paratii.eth.events */ addSubscription (eventType, subscription) { if (!this._subscriptions[eventType]) { this._subscriptions[eventType] = [] } // const key = this._subscriptions[eventType].length subscription.eventType = eventType // subscription.id = key // console.log(subscription) this._subscriptions[eventType].push(subscription) return subscription } /** * [removeAllSubscriptions description] * TODO RIVEDI I TIPI * @param {Object} eventType [description] * @return {Object} [description] * @memberof paratii.eth.events */ removeAllSubscriptions (eventType) { if (eventType === undefined) { this._subscriptions = {} } else { delete this._subscriptions[eventType] } } // // getSubscriptionsForType (eventType) { // return this._subscriptions[eventType] // } // // removeSubscription (subscription) { // const eventType = subscription.eventType // const key = subscription.key // // const subscriptionsForType = this._subscriptions[eventType] // if (subscriptionsForType) { // delete subscriptionsForType[key] // } // } } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.eth.tcr.js.html":{"id":"paratii.eth.tcr.js.html","title":"Source: paratii.eth.tcr.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.eth.tcr.js 'use strict' import { getInfoFromLogs } from './utils.js' /** * TCR functionality * @param {object} context ParatiiEth Instance * @return {TCR} returns instances of Tcr * @class paratii.eth.tcr */ export class ParatiiEthTcr { constructor (context) { this.eth = context } /** * get TCR contract instance. * @return {Promise} Contract instance. * @memberof paratii.eth.tcr */ async getTcrContract () { let contract = await this.eth.getContract('TcrPlaceholder') if (contract.options.address === '0x0') { throw Error('There is no TCR contract known in the registry') } return contract } /** * get the minimum amount required to stake a video. * @return {Float} amount required in PTI * @todo return amount as bignumber.js Object * @memberof paratii.eth.tcr */ async getMinDeposit () { let contract = await this.getTcrContract() let minDeposit = await contract.methods.getMinDeposit().call() return minDeposit } /** * check if video is already whitelisted or not. note that this returns false * till the video is actually whitelisted. use didVideoApply in case you want * to check whether the video is in application process. * @param {string} videoId videoId * @return {boolean} is video whitelisted or not. * @memberof paratii.eth.tcr */ async isWhitelisted (videoId) { let contract = await this.getTcrContract() let isWhitelisted = await contract.methods.isWhitelisted(videoId).call() return isWhitelisted } /** * check whether a video started the application process or not yet. * @param {string} videoId videoId * @return {boolean} did the video start the TCR process. * @memberof paratii.eth.tcr */ async didVideoApply (videoId) { let contract = await this.getTcrContract() let appWasMade = await contract.methods.appWasMade(videoId).call() return appWasMade } /** * start the application process. * NOTE that this require the client approves PTI amount first before actually * running this function, use `checkEligiblityAndApply` instead. * @param {string} videoId videoId * @param {Float} amountToStake number of tokens to stake. must &gt;= minDeposit * @return {boolean} returns true if all is good, plus _Application * event. * @memberof paratii.eth.tcr */ async apply (videoId, amountToStake) { // FIXME: it is more efficient if we first call &quot;apply&quot;, and check for preconditions only after this failed let minDeposit = await this.getMinDeposit() if (this.eth.web3.utils.toBN(amountToStake).lt(minDeposit)) { throw new Error(`amount to stake ${amountToStake} is less than minDeposit ${minDeposit.toString()}`) } let contract = await this.getTcrContract() // let amountInWei = this.eth.web3.utils.toWei(amountToStake.toString()) let amountInHex = this.eth.web3.utils.toHex(amountToStake.toString()) // console.log('amountInHex: ', amountInHex) let tx try { tx = await contract.methods.apply(videoId, amountInHex).send() } catch (error) { throw error } // console.log('tx: ', tx) let vId try { vId = getInfoFromLogs(tx, '_Application', 'videoId', 1) } catch (e) { // FIXME: thsi error should be thrown if (e) { return false } } // console.log('vId: ', vId) if (vId) { return true } else { return false } } /** * Stake amountToStake on video with id videoId * does a number of separate steps: * - check preconditions for staking * - approve that the TCR contract can transfer amountToStake tokens * - apply to the TCR * @param {strin} videoId [description] * @param {number} amountToStake [description] * @return {Promise} [description] * @memberof paratii.eth.tcr */ // FIXME: better naming async checkEligiblityAndApply (videoId, amountToStake) { let minDeposit = await this.getMinDeposit() if (this.eth.web3.utils.toBN(amountToStake).lt(minDeposit)) { throw new Error(`amount to stake ${amountToStake} is less than minDeposit ${minDeposit.toString()}`) } // check if the videoId was already applied or is whitelisted let isWhitelisted = await this.isWhitelisted(videoId) if (isWhitelisted) { throw new Error(`video ${videoId} is already whitelisted`) } let appWasMade = await this.didVideoApply(videoId) if (appWasMade) { throw new Error(`video ${videoId} already applied and awaiting decision`) } // get some tokens let token = await this.eth.getContract('ParatiiToken') let tcrPlaceholder = await this.eth.getContract('TcrPlaceholder') // FIXME: restore this logic (it is broken!) // let balance = await token.methods.balanceOf(this.eth.config.account.address).call() // if (this.eth.web3.utils.toBN(balance.toString()).lt(amountToStake)) { // throw new Error(`Your balance is to low: it is ${balance.toString()}, while a minimal deposit of ${minDeposit.toString()} is required`) // } let tx2 = await token.methods.approve(tcrPlaceholder.options.address, amountToStake).send() if (!tx2) { throw new Error('checkEligiblityAndApply Error ', tx2) } let allowance = await token.methods.allowance(this.eth.config.account.address, tcrPlaceholder.options.address).call() if (allowance.toString() !== amountToStake.toString()) { console.warn(`allowance ${allowance.toString()} != ${amountToStake.toString()}`) } let result = await this.apply(videoId, amountToStake) return result } /** * remove the video given by videoId from the listing * @memberof paratii.eth.tcr */ async exit (videoId) { let contract = await this.getTcrContract() return contract.methods.exit(videoId).send() } } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.eth.users.js.html":{"id":"paratii.eth.users.js.html","title":"Source: paratii.eth.users.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.eth.users.js const joi = require('joi') /** * The eth.user namespace contains functions to interact with the video registration on the blockchain. * @class paratii.eth.users */ export class ParatiiEthUsers { constructor (context) { // context is a ParatiiEth instance this.eth = context } /** * Get the contract instance of the user contract * @return {Promise} Object representing the contract * @memberof paratii.eth.users */ async getRegistry () { return this.eth.getContract('Users') } /** * Creates a user * @param {Object} options information about the user * @param {String} options.id valid address * @param {String} options.name name of the user * @param {String} options.email email of the user * @param {String} options.ipfsData ipfs hash * @return {Promise} the id of the newly created user * @example let userData = { * id: 'some-id', * name: 'Humbert Humbert', * email: 'humbert@humbert.ru', * ipfsData: 'some-hash' * } * let result = await paratii.eth.users.create(userData) * @memberof paratii.eth.users */ async create (options) { const schema = joi.object({ id: joi.string(), name: joi.string(), email: joi.string(), ipfsData: joi.string() }) if (!this.eth.web3.utils.isAddress(options.id)) { let msg = `The &quot;id&quot; argument should be a valid address, not ${options.id}` throw Error(msg) } const result = joi.validate(options, schema) const error = result.error if (error) throw error options = result.value let contract = await this.getRegistry() await contract.methods.create(options.id, options.name, options.email, options.ipfsData).send() return options.id } /** * Get a users details from the blockchain * @param {String} userId valid address * @return {Promise} information about the user * @example user = await paratii.eth.users.get('some-id') * @memberof paratii.eth.users */ async get (userId) { let contract = await this.getRegistry() let userInfo = await contract.methods.get(userId).call() let result = { id: userId, name: userInfo[0], email: userInfo[1], ipfsData: userInfo[2] } return result } /** * Updates a user details on the blockchain. * @param {String} userId valid address * @param {Object} options information to update. Left-out data is kept the same. * @return {Promise} updated data * @example await paratii.eth.users.update('some-id', {ipfsData: 'new-hash'}) * @memberof paratii.eth.users */ async update (userId, options) { options.id = userId let data = await this.get(userId) for (let key in options) { data[key] = options[key] } await this.create(data) return data } /** * Deletes a user from the blockchain. Can only be called by the contract owner or the user him/her-self * @param {String} userId valid address * @return {Promise} blockchain transaction * @example await paratii.eth.users.delete('some-id') * @memberof paratii.eth.users */ async delete (userId) { let contract = await this.getRegistry() let tx = contract.methods.remove(userId).send() return tx } } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.eth.vids.js.html":{"id":"paratii.eth.vids.js.html","title":"Source: paratii.eth.vids.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.eth.vids.js import { getInfoFromLogs, makeId, NULL_ADDRESS } from './utils.js' const joi = require('joi') /** * The eth.vids namespace contains functions to interact with the video registration on the blockchain. * @class paratii.eth.vids */ export class ParatiiEthVids { constructor (context) { // context is a ParatiiEth instance this.eth = context } /** * Get the contract instance of the videos contract * @return {Promise} Object representing the contract * @example let contract = await paratii.eth.vids.getVideoRegistry() * @memberof paratii.eth.vids */ async getVideoRegistry () { let contract = await this.eth.getContract('Videos') if (contract.options.address === '0x0') { throw Error('There is not Videos contract known in the registry') } return contract } /** * Get the contract instance of the likes contract * @return {Promise} Object representing the contract * @example let contract = await paratii.eth.vids.getLikesContract() * @memberof paratii.eth.vids */ async getLikesContract () { let contract = await this.eth.getContract('Likes') if (contract.options.address === '0x0') { throw Error('There is not Likes contract known in the registry') } return contract } /** * Get the contract instance of the views contract * @return {Promise} Object representing the contract * @example let contract = await paratii.eth.vids.getViewsContract() * @memberof paratii.eth.vids */ async getViewsContract () { let contract = await this.eth.getContract('Views') if (contract.options.address === '0x0') { throw Error('There is not Views contract known in the registry') } return contract } /** * Creates a random id * @return {String} id created * @example let id = paratii.eth.vids.makeId() * @memberof paratii.eth.vids */ makeId () { // create a fresh ID return makeId() } /** * Record the video on the blockchain * @param {Object} options data about the video * @param {Number} [retry=1] optional, default = 1 * @return {Promise} the video id * @example let videoId = await paratii.eth.vids.create({ * id: 'some-id', * price: 20, * owner: 'some-address', * ipfsHash: 'some-hash' * }) * @memberof paratii.eth.vids */ async create (options, retry = 1) { const schema = joi.object({ id: joi.string(), owner: joi.string().required(), price: joi.any().default(0), ipfsHashOrig: joi.string().empty('').default(''), ipfsHash: joi.string().empty('').default(''), ipfsData: joi.string().default('') }) const result = joi.validate(options, schema) if (result.error) { throw result.error } const validatedOptions = result.value if (!validatedOptions.id) { validatedOptions.id = this.makeId() } if (!this.eth.web3.utils.isAddress(validatedOptions.owner)) { let msg = `The owner argument should be a valid address, not ${validatedOptions.owner}` throw Error(msg) } let contract = await this.getVideoRegistry() try { let tx = await contract.methods.create( validatedOptions.id, validatedOptions.owner, validatedOptions.price, validatedOptions.ipfsHashOrig, validatedOptions.ipfsHash, validatedOptions.ipfsData ).send() let videoId = getInfoFromLogs(tx, 'LogCreateVideo', 'videoId') return videoId } catch (err) { if (/Transaction nonce is too low./.exec(err.message) &amp;&amp; retry &gt; 0) { return this.create(options, retry - 1) } if (/There is another transaction with same nonce in the queue./.exec(err.message) &amp;&amp; retry &gt; 0) { return this.create(options, retry - 1) } if (/Transaction with the same hash was already imported./.exec(err.message)) { // this means that there is no need to send this transaction again return validatedOptions.id } throw err } } /** * get data about the video * @param {String} videoId univocal video id * @return {Promise} data about the video * @example let video = eth.vids.get('0x12345') * @memberof paratii.eth.vids */ async get (videoId) { let contract = await this.getVideoRegistry() let videoInfo = await contract.methods.get(videoId).call() let result = { id: videoId, owner: videoInfo[0], price: videoInfo[1], ipfsHashOrig: videoInfo[2], ipfsHash: videoInfo[3], ipfsData: videoInfo[4] } if (result.owner === NULL_ADDRESS) { throw Error(`No video with id '${videoId}' was registered`) } return result } /** * record a like/dislike to the video on the blockchain * TODO RIVEDI I TIPI * @param {Object} options data about the video to like * @param {String} options.videoId univocal video id * @param {Boolean} options.liked true/false * @return {Promise} transaction recording the like * @example await paratii.eth.vids.sendLike({ videoId: 'some-id', liked: true }) * @example await paratii.eth.vids.sendLike({ videoId: 'some-id', liked: false }) * @memberof paratii.eth.vids */ async sendLike (options) { const schema = joi.object({ videoId: joi.string().required(), liked: joi.bool().required() }) const result = joi.validate(options, schema) const error = result.error if (error) throw error options = result.value if (options.liked !== true &amp;&amp; options.liked !== false) { let msg = 'The liked argument should be a boolean' throw Error(msg) } let contract = await this.getVideoRegistry() let contract2 = await this.getLikesContract() let videoInfo = await contract.methods.get(options.videoId).call() if (videoInfo[0] === NULL_ADDRESS) { let msg = `Video with ID '${options.videoId}' doesn't exist` throw Error(msg) } let tx = await contract2.methods.likeVideo( options.videoId, options.liked ).send() return tx } /** * record a views to the video on the blockchain * @param {Object} options data about the video and the viewer * @param {String} options.viewer address of the viewer * @param {String} options.videoId univocal video identifier * @param {String} options.ipfsData ipfs multihash * @return {Promise} transaction recording the view * @example await paratii.eth.vids.view({viewer:'some-user-id',videoId: 'some-video-id'}) * @memberof paratii.eth.vids */ async view (options) { const schema = joi.object({ viewer: joi.string().required(), videoId: joi.string().required(), ipfsData: joi.string().default(null) }) const result = joi.validate(options, schema) const error = result.error if (error) throw error options = result.value let contract = await this.getViewsContract() let tx = await contract.methods.create( options.viewer, options.videoId, options.ipfsData ).send() return tx } /** * Check if the viewer has already viewed the video * @param {Object} options data about the video and the viewer * @param {String} options.viewer viewer address * @param {String} options.videoId univocal video identifier * @return {Promise} true if the current user already viewed the video, false otherwise * @example let result = await paratii.eth.vids.userViewedVideo({viewer:'some-user-id',videoId: 'some-video-id'}) * @memberof paratii.eth.vids */ async userViewedVideo (options) { const schema = joi.object({ viewer: joi.string().required(), videoId: joi.string().required() }) const result = joi.validate(options, schema) const error = result.error if (error) throw error options = result.value let contract = await this.getViewsContract() return contract.methods.userViewedVideo( options.viewer, options.videoId ).call() } /** * Writes a like for the video on the blockchain (contract Likes), and negates a dislike for the video, if it exists. * @param {String} videoId univocal video identifier * @return {Promise} transaction recording the like * @example let result = paratii.eth.vids.like('some-id') * @memberof paratii.eth.vids */ async like (videoId) { await this.sendLike({ videoId: videoId, liked: true }) } /** * Writes a dislike for the video on the blockchain (contract Likes), and negates a like for the video, if it exists. * @param {String} videoId univocal video identifier * @return {Promise} transaction recording the dislike * @example let result = paratii.eth.vids.dislike('some-id') * @memberof paratii.eth.vids */ async dislike (videoId) { await this.sendLike({ videoId: videoId, liked: false }) } /** * Check if the current user has already liked the video * @param {String} videoId univocal video identifier * @return {Promise} true if the current user already liked the video, false otherwise * @example let result = paratii.eth.vids.doesLike('some-id') * @memberof paratii.eth.vids */ async doesLike (videoId) { let contract = await this.getLikesContract() let address = this.eth.config.account.address let likeInfo = await contract.methods.userLikesVideo(address, videoId).call() return likeInfo } /** * Check if the current user has already disliked the video. * @param {String} videoId univocal video identifier * @return {Promise} true if the current user already disliked the video, false otherwise * @example let result = paratii.eth.vids.doesDislike('some-id') * @memberof paratii.eth.vids */ async doesDislike (videoId) { let contract = await this.getLikesContract() let address = this.eth.config.account.address let likeInfo = await contract.methods.userDislikesVideo(address, videoId).call() return likeInfo } /** * Update the information on the video. * Only the account that has registered the video, or the owner of the contract, can update the information. * @param {String} videoId univocal video identifier * @param {Object} options key value pairs of properties and new values e.g. ({title: 'another-title'}) * @return {Promise} Updated video informations * @example paratii.eth.vids.update('some-video-id', {title: 'another-title'}) * @memberof paratii.eth.vids */ async update (videoId, options) { options.id = videoId let data = await this.get(videoId) for (let key in options) { data[key] = options[key] } await this.create(data, 'updating') return data } /** * delete the video from the blockchain * @param {String} videoId univocal video identifier * @return {Promise} transaction recording the remove action * @example let tx = paratii.eth.vids.delete('some-id') */ async delete (videoId) { let contract = await this.getVideoRegistry() // contract.setProvider(this.eth.config.provider) let tx = await contract.methods.remove(videoId).send() return tx } } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.eth.vouchers.js.html":{"id":"paratii.eth.vouchers.js.html","title":"Source: paratii.eth.vouchers.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.eth.vouchers.js import { getInfoFromLogs, NULL_ADDRESS, makeId } from './utils.js' const joi = require('joi') /** * Functions for redeeming vouchers * @class paratii.eth.vouchers */ export class ParatiiEthVouchers { constructor (context) { // context is a ParatiiEth instance this.eth = context } /** * Get the contract instance of the vouchers contract * @return {Promise} Object representing the contract * @example let contract = await paratii.eth.vids.getVouchersContract() * @memberof paratii.eth.vouchers */ async getVouchersContract () { let contract = await this.eth.getContract('Vouchers') if (contract.options.address === '0x0') { throw Error('There is not Vouchers contract known in the registry') } return contract } /** * Function for creating a voucher. Can only be called by the owner of the contract. * @param {Object} options data about the voucher * @param {String} options.voucherCode unique string associated to this voucher * @param {Number} options.amount amount of PTI in wei of this voucher * @return {Promise} the voucher id * @example await paratii.eth.vouchers.create({ voucherCode: 'some-id', amount: 10 }) * @memberof paratii.eth.vouchers */ async create (options) { const schema = joi.object({ voucherCode: joi.string(), amount: joi.number() }) const result = joi.validate(options, schema) const error = result.error if (error) throw error options = result.value if (options.voucherCode === null) { let msg = 'Voucher Code argument must not be null' throw Error(msg) } if (typeof options.voucherCode !== 'string') { let msg = 'Voucher Code argument needs to be a string' throw Error(msg) } if (typeof options.amount !== 'number') { let msg = 'Amount argument needs to be a number' throw Error(msg) } if (options.amount === 0) { let msg = 'Amount needs to be greater than zero' throw Error(msg) } let contract = await this.getVouchersContract() let hashedVoucher = await contract.methods.hashVoucher(options.voucherCode).call() let tx = await contract.methods.create( hashedVoucher, options.amount ).send() let voucherId = getInfoFromLogs(tx, 'LogCreateVoucher', '_hashedVoucher') return voucherId } /** * throws a test error * @memberof paratii.eth.vouchers */ async test () { throw Error('test error message') } /** * Generates a given number of vouchers with unique IDs, and the given amount, and returns an array of objects. * @param {Number} number number of voucher to create * @param {Number} amount amount of every voucher * @return {Promise} Object containing every voucher created * @example let vouchers = await paratii.eth.vouchers.createVouchers(10, 10) * @memberof paratii.eth.vouchers */ async createVouchers (number, amount) { let i let vouchers = [] for (i = 0; i &lt; number; i++) { let code = makeId() let voucher = { voucherCode: code, amount: amount } await this.create(voucher) vouchers.push(voucher) } return vouchers } /** * Function for redeeming a voucher to the current account's address. * @param {String} voucherCode univocal voucher code * @return {Promise} true if everything goes well, otherwise throws an error * @example await paratii.eth.vouchers.redeem('some-code') * @memberof paratii.eth.vouchers */ async redeem (voucherCode) { let contract = await this.getVouchersContract() let voucherBytes = await contract.methods.hashVoucher(voucherCode).call() let thisVoucher = await contract.methods.vouchers(voucherBytes).call() let thisVoucherClaimant = thisVoucher[0].toString() let thisVoucherAmount = Number(thisVoucher[1]) let vouchersContractBalance = Number(await this.eth.balanceOf(contract.options.address, 'PTI')) if (thisVoucherClaimant !== NULL_ADDRESS) { throw Error('This voucher was already used') } if (thisVoucherAmount &gt; vouchersContractBalance) { throw Error('The Vouchers contract doesn\\'t have enough PTI to redeem the voucher') } if (thisVoucherAmount === Number(0)) { throw Error('This voucher doesn\\'t exist') } try { let tx = await contract.methods.redeem(voucherCode).send() let claimant = getInfoFromLogs(tx, 'LogRedeemVoucher', '_claimant', 1) let amount = getInfoFromLogs(tx, 'LogRedeemVoucher', '_amount', 1) if (claimant === this.eth.config.account.address) { return amount } else { return false } } catch (e) { throw Error('An unknown error occurred') } } } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.eth.wallet.js.html":{"id":"paratii.eth.wallet.js.html","title":"Source: paratii.eth.wallet.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.eth.wallet.js // this code is lifted and adapted from ethereumjs-lightwallet import {add0x} from './utils.js' var bip39 = require('bip39') var hdkey = require('hdkey') /** * overrides some web3js wallet functionalties * @param {Object} wallet wallet to patch * @param {Object} config configuration object to initialize Paratii object * @return {Object} patched wallet * @class paratii.eth.wallet */ export function patchWallet (wallet, config) { /** * Create a wallet with a given number of accounts from a BIP39 mnemonic * @param {Number} numberOfAccounts number of accounts to be created * @param {String} mnemonic optional - mnemonic of the wallet, if not specified a random one is generated * @return {Object} the created wallet * @example wallet = await wallet.create(5, 'some long mnemonic phrase') * @memberof paratii.eth.wallet */ async function create (numberOfAccounts, mnemonic) { if (this.length &gt; 0) { throw Error('This wallet has already been created!') } if (numberOfAccounts === undefined) { numberOfAccounts = 1 } if (mnemonic === undefined) { mnemonic = bip39.generateMnemonic() } if (bip39.validateMnemonic(mnemonic)) { let seed = bip39.mnemonicToSeed(mnemonic) // contains masternode extended priv key and extended pub key let masternode = hdkey.fromMasterSeed(seed) for (let i = 0; i &lt; numberOfAccounts; ++i) { // m / purpose' / coin_type' / account' / change / address_index let child = masternode.derive(`m/44'/60'/0'/0/${i}`) let privkeyHex = child.privateKey.toString('hex') var privateKey = this._accounts.privateKeyToAccount(add0x(privkeyHex)).privateKey this.add(privateKey) } } else { throw Error(`Mnemonic was not valid: ${mnemonic}`) } return this } /** * check if the passed mnemonic is bip39 valid * @param {String} mnemonic mnemonic to check * @return {Boolean} true if the mnemonic is valid, false otherwise * @example paratii.eth.wallet.isValidMnemonic('some long mnemonic phrase') * @memberof paratii.eth.wallet */ function isValidMnemonic (mnemonic) { return bip39.validateMnemonic(mnemonic) } /** * generates a new mnemonic * @return {String} newly generated mnemonic * @example let newMnemonic = paratii.eth.wallet.generateMnemonic() * @memberof paratii.eth.wallet */ function newMnemonic () { return bip39.generateMnemonic() } /* function getMnemonic () { return this._mnemonic } function setPassphrase (passphrase) { this._passphrase = passphrase return this._passphrase } */ let origDecrypt = wallet.decrypt.bind(wallet) /** * decrypts the wallet * @param {Object} data encrypted wallet * @param {String} password password to decrypt * @return {Object} decrypted wallet * @example let decryptedWallet = paratii.eth.wallet._decrypt(encryptedWallet,'some-psw') * @memberof paratii.eth.wallet */ function _decrypt (data, password) { let newWallet = origDecrypt(data, password) if (newWallet) { config.paratii.eth.setAccount(newWallet['0'].address, newWallet['0'].privateKey) } return newWallet } // wallet._mnemonic = undefined // testing purpose // wallet._passphrase = '' // wallet.setPassphrase = setPassphrase wallet.create = create wallet.decrypt = _decrypt wallet.isValidMnemonic = isValidMnemonic wallet.newMnemonic = newMnemonic // wallet.getMnemonic = getMnemonic return wallet } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.ipfs.uploader.js.html":{"id":"paratii.ipfs.uploader.js.html","title":"Source: paratii.ipfs.uploader.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.ipfs.uploader.js /* global File, ArrayBuffer */ 'use strict' import { ipfsSchema } from './schemas.js' import { EventEmitter } from 'events' import joi from 'joi' const pull = require('pull-stream') const pullFilereader = require('pull-filereader') const toPull = require('stream-to-pull-stream') const fs = require('fs') const path = require('path') const { eachSeries, nextTick } = require('async') const once = require('once') const Multiaddr = require('multiaddr') const Resumable = require('resumablejs') /** * IPFS UPLOADER : Paratii IPFS uploader interface. * @extends EventEmitter * @param {Object} opts * @class paratii.ipfs.uploader */ export class Uploader extends EventEmitter { constructor (opts) { super() const schema = joi.object({ ipfs: ipfsSchema, paratiiIPFS: joi.object().optional() // onReadyHook: joi.array().ordered().default([]), // protocol: joi.string().default(null), }) const result = joi.validate(opts, schema, {allowUnknown: true}) if (result.error) throw result.error this.config = result.value this._ipfs = this.config.paratiiIPFS // this is the paratii.ipfs.js } /** * ???? * @param {?} ev ? * @return {?} ? * @memberof paratii.ipfs.uploader */ onDrop (ev) { } /** * Upload a file over XHR to the transcoder. To be called with an event emitter as the last argument * @param {Object} file file to upload * @param {String} hashedFile hash of the file ?? * @param {EventEmitter} ev event emitter * @example this.xhrUpload(file, hashedFile, ev) * @memberof paratii.ipfs.uploader */ xhrUpload (file, hashedFile, ev) { let r = new Resumable({ target: `${this.config.transcoderDropUrl}/${hashedFile.hash}`, chunkSize: this.config.ipfs.xhrChunkSize, simultaneousUploads: 4, testChunks: false, throttleProgressCallbacks: 1, maxFileSize: this.config.ipfs.maxFileSize }) r.on('fileAdded', (file, ev) =&gt; { console.log('file ', file, 'added') }) r.on('fileProgress', (file) =&gt; { ev.emit('progress', r.progress() * 100) }) r.on('complete', () =&gt; { ev.emit('fileReady', hashedFile) }) r.on('error', (err, file) =&gt; { console.error('file ', file, 'err ', err) }) r.addFile(file._html5File) setTimeout(() =&gt; { r.upload() }, 1) } /** * uploads a single file to *local* IPFS node * @param {File} file HTML5 File Object. * @returns {EventEmitter} checkout the upload function below for details. * @example let uploaderEv = paratiiIPFS.uploader.add(files) * @memberof paratii.ipfs.uploader */ add (file) { let files if (Array.isArray(file)) { files = file } else { files = [file] } let result = [] for (let i = 0; i &lt; files.length; i++) { // check if File is actually available or not. // if not it means we're not in the browser land. if (typeof File !== 'undefined') { if (files[i] instanceof File) { result.push(this.html5FileToPull(files[i])) } else { result.push(this.fsFileToPull(files[i])) } } else { result.push(this.fsFileToPull(files[i])) } } return this.upload(result) } /** * returns a generic File Object with a Pull Stream from an HTML5 File * @param {File} file HTML5 File Object * @return {Object} generic file object. * @example ? * @memberof paratii.ipfs.uploader */ html5FileToPull (file) { return { name: file.name, size: file.size, path: file.path, _html5File: file, _pullStream: pullFilereader(file) } } /** * returns a generic file Object from a file path * @param {String} filePath Path to file. * @return {Object} generic file object. * @example ? * @memberof paratii.ipfs.uploader */ fsFileToPull (filePath) { let stats = fs.statSync(filePath) if (stats) { return { name: path.basename(filePath), size: stats.size, _pullStream: toPull(fs.createReadStream(filePath)) } } else { return null } } /** * upload an Array of files as is to the local IPFS node * @param {Array} files HTML5 File Object Array. * @return {EventEmitter} returns EventEmitter with the following events: * - 'start': uploader started. * - 'progress': (chunkLength, progressPercent) * - 'fileReady': (file) triggered when a file is uploaded locally. * - 'done': (files) triggered when the uploader is done locally. * - 'error': (err) triggered whenever an error occurs. * @example ? * @memberof paratii.ipfs.uploader */ upload (files) { let meta = {} // holds File metadata. let ev = new EventEmitter() this._ipfs.start().then(() =&gt; { // trigger onStart callback ev.emit('start') if (files &amp;&amp; files[0] &amp;&amp; files[0].size &gt; this.config.ipfs.maxFileSize) { ev.emit('error', `file size is larger than the allowed ${this.config.ipfs.maxFileSize / 1024 / 1024}MB`) return } pull( pull.values(files), pull.through((file) =&gt; { this._ipfs.log('Adding ', file) meta.fileSize = file.size meta.total = 0 }), pull.asyncMap((file, cb) =&gt; pull( pull.values([{ path: file.name, // content: pullFilereader(file) content: pull( file._pullStream, pull.through((chunk) =&gt; ev.emit('progress2', chunk.length, Math.floor((meta.total += chunk.length) * 1.0 / meta.fileSize * 100))) ) }]), this._node.files.addPullStream({chunkerOptions: {maxChunkSize: this.config.ipfs.chunkSize}}), // default size 262144 pull.collect((err, res) =&gt; { if (err) { return ev.emit('error', err) } const hashedFile = res[0] this._ipfs.log('Adding %s finished as %s, size: %s', hashedFile.path, hashedFile.hash, hashedFile.size) if (file._html5File) { this.xhrUpload(file, hashedFile, ev) } else { ev.emit('fileReady', hashedFile) } cb(null, hashedFile) }) )), pull.collect((err, hashedFiles) =&gt; { if (err) { ev.emit('error', err) } this._ipfs.log('uploader is DONE') ev.emit('done', hashedFiles) }) ) }) return ev } /** * upload an entire directory to IPFS * @param {String} dirPath path to directory * @return {Promise} returns the {multihash, path, size} for the uploaded folder. * @example ? * @memberof paratii.ipfs.uploader */ addDirectory (dirPath) { return new Promise((resolve, reject) =&gt; { // cb = once(cb) let resp = null // this._ipfs.log('adding ', dirPath, ' to IPFS') const addStream = this._node.files.addReadableStream() addStream.on('data', (file) =&gt; { // this._ipfs.log('dirPath ', dirPath) // this._ipfs.log('file Added ', file) if (file.path === dirPath) { // this._ipfs.log('this is the hash to return ') resp = file nextTick(() =&gt; resolve(resp)) } }) addStream.on('end', () =&gt; { // this._ipfs.log('addStream ended') // nextTick(() =&gt; cb(null, resp)) }) fs.readdir(dirPath, (err, files) =&gt; { if (err) return reject(err) eachSeries(files, (file, next) =&gt; { next = once(next) try { this._ipfs.log('reading file ', file) let rStream = fs.createReadStream(path.join(dirPath, file)) rStream.on('error', (err) =&gt; { if (err) { this._ipfs.error('rStream Error ', err) return next() } }) if (rStream) { addStream.write({ path: path.join(dirPath, file), content: rStream }) } } catch (e) { if (e) { this._ipfs.error('createReadStream Error: ', e) } } finally { } // next() nextTick(() =&gt; next()) }, (err) =&gt; { if (err) return reject(err) // addStream.destroy() addStream.end() }) }) }) } /** * signals transcoder(s) to transcode fileHash * @param {String} fileHash IPFS file hash. * @param {Object} options ref: https://github.com/Paratii-Video/paratii-lib/blob/master/docs/paratii-ipfs.md#ipfsuploadertranscodefilehash-options * @return {EventEmitter} returns EventEmitter with the following events: * - 'uploader:progress': (hash, chunkSize, percent) client to transcoder upload progress. * - 'transcoding:started': (hash, author) * - 'transcoding:progress': (hash, size, percent) * - 'transcoding:downsample:ready' (hash, size) * - 'transcoding:done': (hash, transcoderResult) triggered when the transcoder is done - returns the hash of the transcoded file * - 'transcoder:error': (err) triggered whenever an error occurs. * @example ? * @memberof paratii.ipfs.uploader */ transcode (fileHash, options) { const schema = joi.object({ author: joi.string().default('0x'), // ETH/PTI address of the file owner transcoder: joi.string().default(this.config.ipfs.defaultTranscoder), transcoderId: joi.any().default(Multiaddr(this.config.ipfs.defaultTranscoder).getPeerId()) }).unknown() this._ipfs.log('Signaling transcoder...') const result = joi.validate(options, schema) const error = result.error if (error) throw error let opts = result.value let ev if (opts.ev) { ev = opts.ev } else { ev = new EventEmitter() } if (fileHash === '') { // empty hash for testing eventemitter ev.emit('transcoding:done', {test: 1}) return ev } let msg = this._ipfs.protocol.createCommand('transcode', {hash: fileHash, author: opts.author, size: opts.size}) // FIXME : This is for dev, so we just signal our transcoder node. // This needs to be dynamic later on. this._node.swarm.connect(opts.transcoder, (err, success) =&gt; { if (err) return ev.emit('transcoding:error', err) opts.transcoderId = opts.transcoderId || Multiaddr(opts.transcoder).getPeerId() this._ipfs.log('transcoderId: ', opts.transcoderId) this._node.swarm.peers((err, peers) =&gt; { this._ipfs.log('peers: ', peers) if (err) return ev.emit('transcoding:error', err) peers.map((peer) =&gt; { try { this._ipfs.log('peerID : ', peer.peer.toB58String(), opts.transcoderId, peer.peer.toB58String() === opts.transcoder) if (peer.peer.toB58String() === opts.transcoderId) { this._ipfs.log(`sending transcode msg to ${peer.peer.toB58String()} with request to transcode ${fileHash}`) this._ipfs.protocol.network.sendMessage(peer.peer, msg, (err) =&gt; { if (err) { ev.emit('transcoding:error', err) return ev } }) } } catch (e) { console.log('PEER ERROR :', e, peer) } }) // paratii transcoder signal. this._ipfs.on('protocol:incoming', this._transcoderRespHander(ev, fileHash)) }) }) return ev } /** * handles responses from the paratii-protocol in case of transcoding. * @param {EventEmitter} ev the transcoding job EventEmitter * @return {function} returns various events based on transcoder response. * @example ? * @memberof paratii.ipfs.uploader */ _transcoderRespHander (ev, fileHash) { return (peerId, command) =&gt; { this._ipfs.log('paratii protocol: Received command ', command.payload.toString(), 'args: ', command.args.toString()) let commandStr = command.payload.toString() let argsObj try { argsObj = JSON.parse(command.args.toString()) } catch (e) { this._ipfs.error('couldn\\'t parse args, ', command.args.toString()) } switch (commandStr) { case 'transcoding:error': console.log('DEBUG TRANSCODER ERROR: fileHash: ', fileHash, ' , errHash: ', argsObj.hash) if (argsObj.hash === fileHash) { ev.emit('transcoding:error', argsObj.err) } break case 'transcoding:started': if (argsObj.hash === fileHash) { ev.emit('transcoding:started', argsObj.hash, argsObj.author) } break case 'transcoding:progress': if (argsObj.hash === fileHash) { ev.emit('transcoding:progress', argsObj.hash, argsObj.size, argsObj.percent) } break case 'uploader:progress': if (argsObj.hash === fileHash) { ev.emit('uploader:progress', argsObj.hash, argsObj.chunkSize, argsObj.percent) } break case 'transcoding:downsample:ready': if (argsObj.hash === fileHash) { ev.emit('transcoding:downsample:ready', argsObj.hash, argsObj.size) } break case 'transcoding:done': if (argsObj.hash === fileHash) { let result = JSON.parse(argsObj.result.toString()) ev.emit('transcoding:done', argsObj.hash, result) } break default: if (argsObj.hash === fileHash) { this._ipfs.log('unknown command : ', commandStr) } } } } /** * convenience method for adding and transcoding files * @param {Array} files Array of HTML5 File Objects * @memberof paratii.ipfs.uploader */ addAndTranscode (files) { let ev = this.add(files) // ev.on('done', this._signalTranscoder.bind(this)) ev.on('done', (files) =&gt; { this._signalTranscoder(files, ev) }) return ev } /** * [_signalTranscoder description] * TODO RIVEDI I TIPI * @param {Object} files [description] * @param {Object} ev [description] * @return {Object} [description] * @memberof paratii.ipfs.uploader */ _signalTranscoder (files, ev) { let file if (Array.isArray(files)) { if (files.length &lt; 1) { // FIXME THIS NEEDS TO BE REMOVED file = {hash: ''} // testing something ... // this._ipfs.log('_signalTranscoder Got an empty Array. files: ', files) // return } else { file = files[0] } } else { file = files } if (!ev) { ev = new EventEmitter() } this.transcode(file.hash, { author: '0x', // author address, ev: ev }) } /** * [getMetaData description] * @param {Object} fileHash [description] * @param {Object} options [description] * @return {Object} [description] * @memberof paratii.ipfs.uploader */ getMetaData (fileHash, options) { return new Promise((resolve, reject) =&gt; { const schema = joi.object({ transcoder: joi.string().default(this.config.ipfs.defaultTranscoder), transcoderId: joi.any().default(Multiaddr(this.config.ipfs.defaultTranscoder).getPeerId()) }).unknown() this._ipfs.log('Signaling transcoder getMetaData...') const result = joi.validate(options, schema) const error = result.error if (error) reject(error) let opts = result.value console.log('opts: ', opts) let ev if (opts.ev) { ev = opts.ev } else { ev = new EventEmitter() } this._ipfs.start().then(() =&gt; { let msg = this._ipfs.protocol.createCommand('getMetaData', {hash: fileHash}) // FIXME : This is for dev, so we just signal our transcoder node. // This needs to be dynamic later on. this._ipfs.ipfs.swarm.connect(opts.transcoder, (err, success) =&gt; { if (err) return reject(err) opts.transcoderId = opts.transcoderId || Multiaddr(opts.transcoder).getPeerId() this._ipfs.log('transcoderId: ', opts.transcoderId) this._node.swarm.peers((err, peers) =&gt; { this._ipfs.log('peers: ', peers) if (err) return reject(err) peers.map((peer) =&gt; { this._ipfs.log('peerID : ', peer.peer.id.toB58String(), opts.transcoderId, peer.peer.id.toB58String() === opts.transcoder) if (peer.peer.id.toB58String() === opts.transcoderId) { this._ipfs.log(`sending getMetaData msg to ${peer.peer.id.toB58String()} with request to transcode ${fileHash}`) this._ipfs.protocol.network.sendMessage(peer.peer.id, msg, (err) =&gt; { if (err) { ev.emit('getMetaData:error', err) return ev } }) } }) // paratii getMetaData signal. this._ipfs.on('protocol:incoming', (peerId, command) =&gt; { this._ipfs.log('paratii protocol: Received command ', command.payload.toString(), 'args: ', command.args.toString()) let commandStr = command.payload.toString() let argsObj try { argsObj = JSON.parse(command.args.toString()) } catch (e) { this._ipfs.error('couldn\\'t parse args, ', command.args.toString()) } switch (commandStr) { case 'getMetaData:error': if (argsObj.hash === fileHash) { console.log('DEBUG getMetaData ERROR: fileHash: ', fileHash, ' , errHash: ', argsObj.hash) reject(argsObj.err) } break case 'getMetaData:done': if (argsObj.hash === fileHash) { console.log('data: ', argsObj.data) let result = argsObj.data resolve(result) } break default: this._ipfs.log('unknown command : ', commandStr) } }) }) }) }) }) } /** * [pinFile description] * @param {Object} fileHash [description] * @param {Object} options [description] * @return {Object} [description] * @memberof paratii.ipfs.uploader */ pinFile (fileHash, options) { if (options === undefined) options = {} const schema = joi.object({ author: joi.string().default('0x'), // ETH/PTI address of the file owner transcoder: joi.string().default(this.config.ipfs.defaultTranscoder), transcoderId: joi.any().default(Multiaddr(this.config.ipfs.defaultTranscoder).getPeerId()), size: joi.number().default(0) }).unknown() this._ipfs.log(`Signaling transcoder to pin ${fileHash}`) const result = joi.validate(options, schema) const error = result.error if (error) throw error let opts = result.value let ev if (opts.ev) { ev = opts.ev } else { ev = new EventEmitter() } let msg = this._ipfs.protocol.createCommand('pin', {hash: fileHash, author: opts.author, size: opts.size}) // FIXME : This is for dev, so we just signal our transcoder node. // This needs to be dynamic later on. this._node.swarm.connect(opts.transcoder, (err, success) =&gt; { if (err) return ev.emit('pin:error', err) this._node.swarm.peers((err, peers) =&gt; { this._ipfs.log('peers: ', peers) if (err) return ev.emit('pin:error', err) peers.map((peer) =&gt; { try { this._ipfs.log('peer.peer.toB58String(): ', peer.peer.toB58String()) if (peer.peer.toB58String() === opts.transcoderId) { this._ipfs.log(`sending pin msg to ${peer.peer._idB58String} with request to pin ${fileHash}`) this._ipfs.protocol.network.sendMessage(peer.peer, msg, (err) =&gt; { if (err) { ev.emit('pin:error', err) return ev } }) } } catch (e) { console.log('PEER ERROR :', e, peer) } }) // paratii pinning response. this._ipfs.on('protocol:incoming', this._pinResponseHandler(ev)) }) }) return ev } /** * [_pinResponseHandler description] * @param {Object} ev [description] * @return {Object} [description] * @memberof paratii.ipfs.uploader */ _pinResponseHandler (ev) { return (peerId, command) =&gt; { this._ipfs.log('paratii protocol: Received command ', command.payload.toString(), 'args: ', command.args.toString()) let commandStr = command.payload.toString() let argsObj try { argsObj = JSON.parse(command.args.toString()) } catch (e) { this._ipfs.log('couldn\\'t parse args, ', command.args.toString()) } switch (commandStr) { case 'pin:error': ev.emit('pin:error', argsObj.err) break case 'pin:progress': ev.emit('pin:progress', argsObj.hash, argsObj.chunkSize, argsObj.percent) break case 'pin:done': ev.emit('pin:done', argsObj.hash) break default: this._ipfs.log('unknown command : ', commandStr) } } } // grabYt (url, onResponse, callback) { // let starttime // let fileSize // let video = ytdl(url) // video.once('response', () =&gt; { // this._ipfs.log(`starting ${url}`) // starttime = Date.now() // onResponse(null, starttime) // }) // // video.on('error', (err) =&gt; { // onResponse(err) // }) // // video.on('progress', (chunkLength, downloaded, total) =&gt; { // fileSize = total // // const floatDownloaded = downloaded / total // // const downloadedMinutes = (Date.now() - starttime) / 1000 / 60 // // readline.cursorTo(process.stdout, 0) // // process.stdout.write(`${(floatDownloaded * 100).toFixed(2)}% downloaded`) // // process.stdout.write(`(${(downloaded / 1024 / 1024).toFixed(2)}MB of ${(total / 1024 / 1024).toFixed(2)}MB)\\n`) // // process.stdout.write(`running for: ${downloadedMinutes.toFixed(2)}minutes`) // // process.stdout.write(`, estimated time left: ${(downloadedMinutes / floatDownloaded - downloadedMinutes).toFixed(2)}minutes `) // // readline.moveCursor(process.stdout, 0, -1) // }) // // video.on('end', () =&gt; { // process.stdout.write('\\n\\n') // // cb(null, output) // }) // // var total = 0 // function updateProgress (chunkLength) { // total += chunkLength // this._ipfs.log('Progress \\t', total, ' / ', fileSize, ' = ', Math.floor((total / fileSize) * 100)) // } // // pull( // pull.values([{ // path: url, // content: pull( // toPull(video), // pull.through((chunk) =&gt; updateProgress(chunk.length)) // ) // }]), // this._node.files.addPullStream({chunkerOptions: {maxChunkSize: this._chunkSize}}), // default size 262144 // this._signalTranscoderPull(callback) // ) // } // // grabVimeo (url, onResponse, callback) { // let starttime // // let total = 0 // let video = vidl(url, {quality: '720p'}) // // video.once('response', () =&gt; { // this._ipfs.log(`starting ${url}`) // starttime = Date.now() // onResponse(null, starttime) // }) // // video.on('data', (chunk) =&gt; { // // total += chunk.length / 1024 / 1024 // }) // // video.on('end', () =&gt; { // // process.stdout.write('\\n\\n') // // cb(null, output) // }) // // function updateProgress (chunkLength) { // // this._ipfs.log('Progress \\t', total, ' / ', fileSize, ' = ', Math.floor((total / fileSize) * 100)) // } // // pull( // pull.values([{ // path: url, // content: pull( // toPull(video), // pull.through((chunk) =&gt; updateProgress(chunk.length)) // ) // }]), // this._node.files.addPullStream({chunkerOptions: {maxChunkSize: this._chunkSize}}), // default size 262144 // this._signalTranscoderPull(callback) // ) // } // } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.ipfs.js.html":{"id":"paratii.ipfs.js.html","title":"Source: paratii.ipfs.js","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Source: paratii.ipfs.js import Protocol from 'paratii-protocol' import { ipfsSchema, accountSchema } from './schemas.js' import joi from 'joi' import { EventEmitter } from 'events' import { Uploader } from './paratii.ipfs.uploader.js' global.Buffer = global.Buffer || require('buffer').Buffer /** * Contains functions to interact with the IPFS instance. * @param {Object} config configuration object to initialize Paratii object */ export class ParatiiIPFS extends EventEmitter { constructor (config) { super() const schema = joi.object({ ipfs: ipfsSchema, account: accountSchema, verbose: joi.bool().default(false) // onReadyHook: joi.array().ordered().default([]), // protocol: joi.string().default(null), }) const result = joi.validate(config, schema, {allowUnknown: true}) if (result.error) throw result.error this.config = config this.config.ipfs = result.value.ipfs this.config.account = result.value.account this.uploader = new Uploader({ipfs: this.config.ipfs, paratiiIPFS: this}) } /** * Adds the file to ipfs * @param {ReadStream} fileStream ReadStream of the file. Can be created with fs.createReadStream(path) * @return {Promise} data about the added file (path,multihash,size) * @example * let path = 'test/data/some-file.txt' * let fileStream = fs.createReadStream(path) * let result = await paratiiIPFS.add(fileStream) */ async add (fileStream) { let ipfs = await this.getIPFSInstance() return ipfs.files.add(fileStream) } /** * get file from ipfs * @param {String} hash multihash of the file * @return {Promise} the file (path,content) * @example * let result = await paratiiIPFS.add(fileStream) * let hash = result[0].hash * let fileContent = await paratiiIPFS.get(hash) */ async get (hash) { let ipfs = await this.getIPFSInstance() return ipfs.files.get(hash) } /** * log messages on the console if verbose is set * @param {String} msg text to log * @example * paratii.ipfs.log(&quot;some-text&quot;) */ log (...msg) { if (this.config.verbose) { console.log(...msg) } } /** * log warns on the console if verbose is set * @param {String} msg warn text * @example * paratii.ipfs.warn(&quot;some-text&quot;) */ warn (...msg) { if (this.config.verbose) { console.warn(...msg) } } /** * log errors on the console if verbose is set * @param {String} msg error message * @example * paratii.ipfs.error(&quot;some-text&quot;) */ error (...msg) { if (this.config.verbose) { console.error(...msg) } } /** * get an ipfs instance of jsipfs. Singleton pattern * @return {Object} Ipfs instance * @example ipfs = await paratii.ipfs.getIPFSInstance() */ getIPFSInstance () { return new Promise((resolve, reject) =&gt; { if (this.ipfs) { resolve(this.ipfs) } else { let config = this.config // there will be no joi in IPFS (pun indended) import(/* webpackChunkName: 'ipfs' */ 'ipfs') // eslint-disable-line .then((Ipfs) =&gt; { let ipfs = new Ipfs({ bitswap: { // maxMessageSize: 256 * 1024 maxMessageSize: this.config.ipfs['bitswap.maxMessageSize'] }, start: true, repo: config.ipfs.repo || '/tmp/test-repo-' + String(Math.random()), config: { Addresses: { Swarm: this.config.ipfs.swarm // [ // '/dns4/star.paratii.video/tcp/443/wss/p2p-webrtc-star', // '/dns4/ws.star.paratii.video/tcp/443/wss/p2p-websocket-star/' // ] }, Bootstrap: this.config.ipfs.bootstrap // [ // '/dns4/bootstrap.paratii.video/tcp/443/wss/ipfs/QmeUmy6UtuEs91TH6bKnfuU1Yvp63CkZJWm624MjBEBazW' // ] } }) this.ipfs = ipfs ipfs.on('ready', () =&gt; { this.log('[IPFS] node Ready.') ipfs._bitswap.notifications.on('receivedNewBlock', (peerId, block) =&gt; { this.log('[IPFS] receivedNewBlock | peer: ', peerId.toB58String(), ' block length: ', block.data.length) this.log('---------[IPFS] bitswap LedgerMap ---------------------') ipfs._bitswap.engine.ledgerMap.forEach((ledger, peerId, ledgerMap) =&gt; { this.log(`${peerId} : ${JSON.stringify(ledger.accounting)}\\n`) }) this.log('-------------------------------------------------------') }) ipfs.id().then((id) =&gt; { let peerInfo = id this.id = id this.log(`[IPFS] id: ${peerInfo}`) let ptiAddress = this.config.account.address || 'no_address' this.protocol = new Protocol( ipfs._libp2pNode, ipfs._repo.blocks, // add ETH Address here. ptiAddress ) this.uploader._node = ipfs // this.uploader.setOptions({ // node: ipfs, // chunkSize: 128 * 1024 // }) this.protocol.notifications.on('message:new', (peerId, msg) =&gt; { this.log('[paratii-protocol] ', peerId.toB58String(), ' new Msg: ', msg) }) // emit all commands. // NOTE : this will be changed once protocol upgrades are ready. this.protocol.notifications.on('command', (peerId, command) =&gt; { this.emit('protocol:incoming', peerId, command) }) this.ipfs = ipfs this.protocol.start(() =&gt; { setTimeout(() =&gt; { resolve(ipfs) }, 10) }) }) }) ipfs.on('error', (err) =&gt; { if (err) { // this.log('IPFS node ', ipfs) this.error('[IPFS] Error ', err) reject(err) } }) }) } }) } /** * adds a data Object to the IPFS local instance * @param {Object} data JSON object to store * @return {Promise} promise with the ipfs multihash * @example let result = await paratiiIPFS.addJSON(data) */ async addJSON (data) { let ipfs = await this.getIPFSInstance() // if (!this.ipfs || !this.ipfs.isOnline()) { // throw new Error('IPFS node is not ready, please trigger getIPFSInstance first') // } const obj = { Data: Buffer.from(JSON.stringify(data)), Links: [] } let node try { // node = await ipfs.object.put(obj) node = await ipfs.files.add(obj.Data) } catch (e) { if (e) throw e } return node[0].hash } /** * convenient method to add JSON and send it for persistance storage. * @param {object} data JSON object to store * @return {string} returns multihash of the stored object. * @example let result = await paratiiIPFS.addAndPinJSON(data) */ async addAndPinJSON (data) { let hash = await this.addJSON(data) let pinFile = () =&gt; { let pinEv = this.uploader.pinFile(hash, { author: this.config.account.address } ) pinEv.on('pin:error', (err) =&gt; { console.warn('pin:error:', hash, ' : ', err) pinEv.removeAllListeners() }) pinEv.on('pin:done', (hash) =&gt; { this.log('pin:done:', hash) pinEv.removeAllListeners() }) return pinEv } let pinEv = pinFile() pinEv.on('pin:error', (err) =&gt; { console.warn('pin:error:', hash, ' : ', err) console.log('trying again') pinEv = pinFile() }) return hash } /** * gets a JSON object stored in IPFS * @param {String} multihash ipfs multihash of the object * @return {Promise} requested Object * @example let jsonObj = await paratiiIPFS.getJSON('some-multihash') */ async getJSON (multihash) { let ipfs = await this.getIPFSInstance() let node try { node = await ipfs.files.cat(multihash) } catch (e) { if (e) throw e } return JSON.parse(node.toString()) } /** * Starts the IPFS node * @param {Function} callback callback function * @return {?} DON'T KNOW? * @example ? */ // TODO: return a promise start () { return new Promise((resolve, reject) =&gt; { if (this.ipfs &amp;&amp; this.ipfs.isOnline()) { console.log('IPFS is already running') return resolve(this.ipfs) } this.getIPFSInstance().then(function (ipfs) { resolve(ipfs) }) }) } /** * Stops the IPFS node. * @param {Function} callback callback function * @return {?} DON'T KNOW? * @example ? */ stop () { return new Promise((resolve, reject) =&gt; { if (!this.ipfs || !this.ipfs.isOnline()) { resolve() } if (this.ipfs) { this.ipfs.stop(() =&gt; { setImmediate(() =&gt; { resolve() }) }) } }) } } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Global Type Definitions accountSchema Type: Array Properties: Name Type Argument Description address string &lt;nullable&gt; privateKey string &lt;nullable&gt; mnemonic string &lt;nullable&gt; Source: schemas.js × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Classes Classes paratii core users vids db users vids eth events tcr users vids vouchers wallet uploader ParatiiIPFS × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global paratii.js paratii.js is the main entry point and abstraction layer to interact with the Paratii platform. More information about the Paratii Project can be found on paratii.video, or in our blueprint. Join the discussion on gitter. How to use itHere is a code snippet which will upload a video to Paratii and transcode it: // import the Paratii object import Paratii from 'paratii-js' // create a new instance of Paratii with default values const paratii = new Paratii() // where is your video? const YOURVID = '/path/to/video.mp4' // go and add the video paratii.vids.uploadAndTranscode({ file: YOURVID, title: 'Paratii for fun and profit' })We have more extensive documentation here: documentation.md Contributing to paratii.jsContributions are most welcome! Please read CONTRIBUTING.md × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.html":{"id":"paratii.html","title":"Class: paratii","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: paratii paratii new paratii(opts) Paratii library main object The Paratii object serves as the general entry point for interacting with the family of Paratii contracts that are deployed on the blockchain, utilities to run and interact with a local IPFS node, and utilities to interact with the Paratii index. Parameters: Name Type Description opts accountSchema options object to configure paratii library Properties Name Type Description provider String optional - the address of an ethereum node (defaults to localhost:8754) registryAddress String optional - the address where the Paratii Contract registry can be found address String optional - address of the operator/user privateKey String optional - private key of the user ipfs Object TODO fix ipfs.repo --&gt; ipfsrepo Properties Name Type Description repo String optional - namespace of the ipfs repository db Object TODO fix db.provider --&gt; dbprovider Properties Name Type Description provider String optional - baseURL of the mongoDb mirror mnemonic String optional - mnemonic of the user Source: paratii.js Example paratii = new Paratii({ 'eth.provider': 'http://localhost:8545', address: 'some-user-id', privateKey: 'some-user-priv-key'}) Classes core db eth Methods &lt;async, static&gt; Paratii#diagnose() return an array of strings with diagnostic info Source: paratii.js Returns: array of strings with diagnostic info Type Promise Example paratii.diagnose() &lt;static&gt; Paratii#setAccount(address, privateKey) Set the ethereum address what will be used to sign all transactions Parameters: Name Type Description address String address of the operator/user privateKey String optional - private key of the operator/user Source: paratii.js Example paratii.setAccount('some-user-id','some-user-pub-key') &lt;static&gt; Paratii#setRegistryAddress(address) Set the address of the ParatiiRegistry contract Parameters: Name Type Description address String address of the ParatiiRegistry contract Source: paratii.js Example paratii.setRegistryAddress('some-address') × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.core.html":{"id":"paratii.core.html","title":"Class: core","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: core paratii. core new core(config) Contains functions that operate transversally over several backend systems. validates the config file and istantiates ParatiiCoreVids and ParatiiCoreUsers. Parameters: Name Type Description config Object configuration object to initialize Paratii object Source: paratii.core.js Classes users vids Methods &lt;async, static&gt; ParatiiCore#migrateAccount() migrate all contract data for paratii.config.account to a new account Source: paratii.core.js × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.core.users.html":{"id":"paratii.core.users.html","title":"Class: users","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: users paratii.core. users new users(config) Utilities to create and manipulate information about the users on the blockchain. Parameters: Name Type Description config Object configuration object to initialize Paratii object Source: paratii.core.users.js Methods &lt;async, static&gt; ParatiiCoreUsers#create(options) Creates a user, fields id, name and email go to the smart contract Users, other fields are stored on IPFS. Parameters: Name Type Description options Object information about the video ( id, name, email ... ) Source: paratii.core.users.js Returns: the id of the newly created user Type Promise Example paratii.core.users.create({ id: 'some-user-id', name: 'A user name', email: 'some@email.com', ... }) &lt;static&gt; ParatiiCoreUsers#get(id) retrieve data about the user Parameters: Name Type Description id String user univocal id Source: paratii.core.users.js Returns: data about the user Type Object Example paratii.core.users.get('some-user-id') &lt;async, static&gt; ParatiiCoreUsers#update(userId, options) Updates a user's details. name and email are defined in the smart contract Users, other fields get written to IPFS. Parameters: Name Type Description userId String user univocal id options Object updated data i.e. { name: 'A new user name' } Source: paratii.core.users.js Returns: updated data about the user Type Promise Example paratii.core.users.update('some-user-id', {name: 'A new user name'}) × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.core.vids.html":{"id":"paratii.core.vids.html","title":"Class: vids","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: vids paratii.core. vids new vids(config) Utilities to create and manipulate information about the videos on the blockchain. Parameters: Name Type Description config Object configuration object to initialize Paratii object Source: paratii.core.vids.js Methods &lt;async, static&gt; ParatiiCoreVids#create(options) This call will register the video on the blockchain, add its metadata to IPFS, upload file to IPFS, and transcode it Parameters: Name Type Description options Object information about the video ( id, title, FilePath ... ) Source: paratii.core.vids.js Returns: information about the video ( id, owner, ipfsHash ... ) Type Promise Example paratii.core.vids.create({ id: 'some-video-id', owner: 'some-user-id', title: 'some Title', author: 'Steven Spielberg', duration: '2h 32m', description: 'A long description', price: 0, file: 'test/data/some-file.txt' }) &lt;static&gt; ParatiiCoreVids#dislike(videoId) Writes a dislike for the video on the blockchain (contract Likes), and negates a like for the video, if it exists. Parameters: Name Type Description videoId String univocal video identifier Source: paratii.core.vids.js Returns: information about the transaction recording the dislike Type Object Example paratii.core.vids.dislike('some-video-id') &lt;static&gt; ParatiiCoreVids#doesDislike(videoId) Check if the current user has already disliked the video Parameters: Name Type Description videoId String univocal video identifier Source: paratii.core.vids.js Returns: true if the current user already disliked the video, false otherwise Type Boolean Example paratii.core.vids.doesDislike('some-video-id') &lt;static&gt; ParatiiCoreVids#doesLike(videoId) Check if the current user has already liked the video Parameters: Name Type Description videoId String univocal video identifier Source: paratii.core.vids.js Returns: true if the current user already liked the video, false otherwise Type Boolean Example paratii.core.vids.doesLike('some-video-id') &lt;async, static&gt; ParatiiCoreVids#get(videoId) Get the data of the video identified by videoId Parameters: Name Type Description videoId String univocal video identifier Source: paratii.core.vids.js Returns: data about the video Type Promise Example paratii.core.vids.get('some-video-id') &lt;static&gt; ParatiiCoreVids#hasViewedVideo(viewer, videoId) Check if the viewer has already viewed the video Parameters: Name Type Description viewer String viewer address videoId String univocal video identifier Source: paratii.core.vids.js Returns: true if the current user already viewed the video, false otherwise Type Boolean Example paratii.core.vids.hasViewedVideo('some-user-id','some-video-id') &lt;static&gt; ParatiiCoreVids#like(videoId) Writes a like for the video on the blockchain (contract Likes), and negates a dislike for the video, if it exists. Parameters: Name Type Description videoId String univocal video identifier Source: paratii.core.vids.js Returns: information about the transaction recording the like Type Object Example paratii.core.vids.like('some-video-id') &lt;static&gt; ParatiiCoreVids#search(options) Get the data of the video Parameters: Name Type Description options Object data about the video and (optional) owner i.e {'keyword':'titleOfTheVideo'} Source: paratii.core.vids.js Returns: data about the video Type Promise Example paratii.core.vids.search({keyword : 'titleOftheVideo'}) the keyword value can be one from the following list - video title - description - owner - uploader.name - uploader.address - tags &lt;async, static&gt; ParatiiCoreVids#update(videoId, options, dataToUpdate) Update the information on the video. Only the account that has registered the video, or the owner of the contract, can update the information. Parameters: Name Type Description videoId String univocal video identifier options Object key value pairs of properties and new values e.g. ({title: 'another-title'}) dataToUpdate Object optional. old data of the video. If not passed to the method, it will fetch the data itself using the videoId Source: paratii.core.vids.js Returns: Updated video informations Type Promise Example paratii.core.vids.update('some-video-id', {title: 'another-title'}) &lt;async, static&gt; ParatiiCoreVids#upsert(options) Update the information of the video the video already exists, otherwise it creates it Parameters: Name Type Description options Object video informations Source: paratii.core.vids.js Returns: updated/new video informations Type Promise Example paratii.core.vids.upsert({ id: 'some-video-id', owner: 'some-user-id', title: 'videoTitle'}) //insert a new video &lt;async, static&gt; ParatiiCoreVids#view(options) Register a view on the blockchain Parameters: Name Type Description options Object should contain keys viewer (address of the viewer) and videoId (univocal video identifier) Source: paratii.core.vids.js Returns: information about the transaction recording the view Type Promise Example paratii.core.vids.view({viewer:'some-user-id',videoId: 'some-video-id'}) × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.db.html":{"id":"paratii.db.html","title":"Class: db","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: db paratii. db new db(config) ParatiiDb contains a functionality to interact with the Paratii Blockchain Index. validates the config file and istantiates ParatiiDbVids and ParatiiDbUsers. Parameters: Name Type Description config Object Source: paratii.db.js Classes users vids × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.db.users.html":{"id":"paratii.db.users.html","title":"Class: users","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: users paratii.db. users new users(config) ParatiiDbUsers contains functionalities regarding the users to interact with the Paratii Blockchain Index Parameters: Name Type Description config Object object to initialize Paratii object Source: paratii.db.users.js Methods &lt;async, static&gt; ParatiiDbUsers#get(userId) retrieve data about the user Parameters: Name Type Description userId String user univocal id Source: paratii.db.users.js Returns: data about the user Type Promise Example paratii.db.users.get('some-user-id') &lt;async, static&gt; ParatiiDbUsers#videos(userId) get information about all the videos of the user Parameters: Name Type Description userId String univocal user identifier Source: paratii.db.users.js Returns: Collection of all the videos of the user Type Promise Example paratii.db.users.videos('some-user-id') × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.db.vids.html":{"id":"paratii.db.vids.html","title":"Class: vids","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: vids paratii.db. vids new vids(config) ParatiiDbUsers contains functionalities regarding the videos to interact with the Paratii Blockchain Index Parameters: Name Type Description config Object object to initialize Paratii object Source: paratii.db.vids.js Methods &lt;async, static&gt; ParatiiDbVids#get(videoId) Get information about this video from the db Parameters: Name Type Description videoId String univocal video identifier Source: paratii.db.vids.js Returns: data about the video Type Promise Example paratii.db.vids.get('some-video-id') &lt;async, static&gt; ParatiiDbVids#search(options) Get the data of the video Parameters: Name Type Description options Object data about the video and (optional) owner i.e {'keyword':'titleOfTheVideo'} Source: paratii.db.vids.js Returns: data about the video Type Promise Example paratii.db.vids.search({keyword : 'titleOftheVideo'}) the keyword value can be one from the following list - video title - description - owner - uploader.name - uploader.address - tags × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.eth.html":{"id":"paratii.eth.html","title":"Class: eth","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: eth paratii. eth new eth(config) contains functions to interact with the Ethereum blockchain and the Paratii contracts deployed there. Parameters: Name Type Description config Object configuration object to initialize Paratii object Source: paratii.eth.js Classes events tcr users vids vouchers wallet Methods &lt;async, static&gt; ParatiiEth#_transferETH(beneficiary, amount, description) send ETH from current account to beneficiary Parameters: Name Type Description beneficiary String ETH address amount Number amount of ETH to be sent description String optional - description of the transaction (will be written in the blockchain) Source: paratii.eth.js Returns: information about the transaction recording the transfer Type Promise Example return paratii.eth._transferETH('some-address', 20, 'an-optional-description') &lt;async, static&gt; ParatiiEth#_transferPTI(beneficiary, amount) send PTI from current account to beneficiary Parameters: Name Type Description beneficiary String ETH address amount Number amount of PTI to be sent Source: paratii.eth.js Returns: information about the transaction recording the transfer Type Promise Example return paratii.eth._transferPTI('some-address', 20) &lt;async, static&gt; ParatiiEth#balanceOf(address, symbol) When called with a second argument, returns the balance of that Token. When called without a second argument, returns information about all relevant balances. Parameters: Name Type Description address String ethereum address symbol String optional - symbol of the token (ETH,PTI) Source: paratii.eth.js Returns: information about balances of that address Type Promise Examples paratii.eth.balanceOf('some-address', 'ETH') // returns the ETH balance of the given address paratii.eth.balanceOf('some-address', 'PTI') // returns the PTI balance of the given address paratii.eth.balanceOf('some-address') // returns both the PTI and the ETH balance of the given address &lt;async, static&gt; ParatiiEth#deployContract(name, args) deploys contract on the blockchain Parameters: Name Type Argument Description name String name of the contract args Object &lt;repeatable&gt; configuration for the contract (strings or numbers). It is allowed to pass more than one parameter Source: paratii.eth.js Returns: the deployed contract Type Promise Example paratii.eth.deployContract('ParatiiToken') &lt;async, static&gt; ParatiiEth#deployContracts() deploy all the contracts on the blockchain Source: paratii.eth.js Returns: all the paratii contracts Type Promise Examples let contracts = await paratii.eth.deployContracts() let likes = await this.deployContract('Likes', paratiiRegistryAddress) &lt;async, static&gt; ParatiiEth#getContract(name) Get the contract instance specified Parameters: Name Type Description name String the name of the token Source: paratii.eth.js Returns: Object representing the contract Type Promise Example paratii.eth.getContract('ParatiiToken') &lt;async, static&gt; ParatiiEth#getContractAddress(name) get the address of the contract on the blockchain Parameters: Name Type Description name String name of the contract Source: paratii.eth.js Returns: Contract address on the blockchain (String) Type Promise Example paratii.eth.getContractAddress('ParatiiToken') &lt;async, static&gt; ParatiiEth#getContracts() return all the contracts Source: paratii.eth.js Returns: all the contracts Type Promise Example let contracts = await paratii.eth.getContracts() &lt;static&gt; ParatiiEth#getRegistryAddress() get the address of the Registry contract on the blockchain Source: paratii.eth.js Returns: address on the blockchain Type String Example let registryAddress = paratii.eth.getRegistryAddress() &lt;static&gt; ParatiiEth#requireContract(contractName) creates the javascript contract object from the json file Parameters: Name Type Description contractName String name of the contract Source: paratii.eth.js Returns: Contract Object Type String Example paratii.eth.requireContract('ParatiiToken') &lt;static&gt; ParatiiEth#setAccount(address, privateKey, mnemonic) creates an account using the private key or, if not present, using the mnemonic Parameters: Name Type Description address String public address privateKey String private key related to the previous public address mnemonic String mnemonic related to the previous public address Source: paratii.eth.js Examples paratii.eth.setAccount('some-address','some-private-key') paratii.eth.setAccount('some-address','some-mnemonic') &lt;async, static&gt; ParatiiEth#setContractsProvider() Set the provider on all the contracts Source: paratii.eth.js Example paratii.eth.setContractsProvider() &lt;static&gt; ParatiiEth#setRegistryAddress(registryAddress) set the address of the Registry contract on the blockchain Parameters: Name Type Description registryAddress String new address Source: paratii.eth.js Example await paratii.eth.setRegistryAddress('some-address') &lt;async, static&gt; ParatiiEth#transfer(beneficiary, amount, symbol, description) Use this to send ETH or PTI from paratii.config.address Parameters: Name Type Description beneficiary String ETH address amount Number amount of ETH/PTI to be sent symbol String symbol of the token to send (ETH,PTI) description String optional - description to be inserted in the blockchain Source: paratii.eth.js Returns: information about the transaction recording the transfer Type Promise Example let result = await paratii.eth.transfer('some-address', 20, 'ETH', 'thanks for all the fish') × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.eth.events.html":{"id":"paratii.eth.events.html","title":"Class: events","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: events paratii.eth. events new events() eth.events implements a part of the API of the EventEmitter, that can be used to manage subscriptions to Ethereum events. Source: paratii.eth.events.js Methods &lt;async, static&gt; ParatiiEthEvents#_addListener(eventType, listener, options) [_addListener description] TODO RIVEDI I TIPI Parameters: Name Type Description eventType Object [description] listener Object [description] options Object [description] Source: paratii.eth.events.js Returns: [description] Type Promise &lt;static&gt; ParatiiEthEvents#_getStructuredEvent(eventType) parse event from simple string to an object Parameters: Name Type Description eventType String Event type Source: paratii.eth.events.js Returns: Event Object Type Object Example let structuredEvent = this._getStructuredEvent('some-event') &lt;static&gt; ParatiiEthEvents#_isFunction(functionToCheck) [_isFunction description] TODO RIVEDI I TIPI Parameters: Name Type Description functionToCheck Object [description] Source: paratii.eth.events.js Returns: [description] Type Boolean &lt;async, static&gt; ParatiiEthEvents#addListener(eventType, options, listener) subscribe to the specified event Parameters: Name Type Description eventType String type of the event options function function called when the events occurs listener ? optional ? Source: paratii.eth.events.js Returns: [description] Type Promise &lt;static&gt; ParatiiEthEvents#addSubscription(eventType, subscription) [addSubscription description] TODO RIVEDI I TIPI Parameters: Name Type Description eventType Object [description] subscription Object [description] Source: paratii.eth.events.js &lt;static&gt; ParatiiEthEvents#removeAllSubscriptions(eventType) [removeAllSubscriptions description] TODO RIVEDI I TIPI Parameters: Name Type Description eventType Object [description] Source: paratii.eth.events.js Returns: [description] Type Object × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.eth.tcr.html":{"id":"paratii.eth.tcr.html","title":"Class: tcr","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: tcr paratii.eth. tcr new tcr(context) TCR functionality Parameters: Name Type Description context object ParatiiEth Instance Source: paratii.eth.tcr.js Returns: returns instances of Tcr Type TCR Methods &lt;async, static&gt; ParatiiEthTcr#apply(videoId, amountToStake) start the application process. NOTE that this require the client approves PTI amount first before actually running this function, use `checkEligiblityAndApply` instead. Parameters: Name Type Description videoId string videoId amountToStake Float number of tokens to stake. must &gt;= minDeposit Source: paratii.eth.tcr.js Returns: returns true if all is good, plus _Application event. Type boolean &lt;async, static&gt; ParatiiEthTcr#checkEligiblityAndApply(videoId, amountToStake) Stake amountToStake on video with id videoId does a number of separate steps: - check preconditions for staking - approve that the TCR contract can transfer amountToStake tokens - apply to the TCR Parameters: Name Type Description videoId strin [description] amountToStake number [description] Source: paratii.eth.tcr.js Returns: [description] Type Promise &lt;async, static&gt; ParatiiEthTcr#didVideoApply(videoId) check whether a video started the application process or not yet. Parameters: Name Type Description videoId string videoId Source: paratii.eth.tcr.js Returns: did the video start the TCR process. Type boolean &lt;async, static&gt; ParatiiEthTcr#exit() remove the video given by videoId from the listing Source: paratii.eth.tcr.js &lt;async, static&gt; ParatiiEthTcr#getMinDeposit() get the minimum amount required to stake a video. Source: paratii.eth.tcr.js To Do: return amount as bignumber.js Object Returns: amount required in PTI Type Float &lt;async, static&gt; ParatiiEthTcr#getTcrContract() get TCR contract instance. Source: paratii.eth.tcr.js Returns: Contract instance. Type Promise &lt;async, static&gt; ParatiiEthTcr#isWhitelisted(videoId) check if video is already whitelisted or not. note that this returns false till the video is actually whitelisted. use didVideoApply in case you want to check whether the video is in application process. Parameters: Name Type Description videoId string videoId Source: paratii.eth.tcr.js Returns: is video whitelisted or not. Type boolean × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.eth.users.html":{"id":"paratii.eth.users.html","title":"Class: users","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: users paratii.eth. users new users() The eth.user namespace contains functions to interact with the video registration on the blockchain. Source: paratii.eth.users.js Methods &lt;async, static&gt; ParatiiEthUsers#create(options) Creates a user Parameters: Name Type Description options Object information about the user Properties Name Type Description id String valid address name String name of the user email String email of the user ipfsData String ipfs hash Source: paratii.eth.users.js Returns: the id of the newly created user Type Promise Example let userData = { id: 'some-id', name: 'Humbert Humbert', email: 'humbert@humbert.ru', ipfsData: 'some-hash' } let result = await paratii.eth.users.create(userData) &lt;async, static&gt; ParatiiEthUsers#delete(userId) Deletes a user from the blockchain. Can only be called by the contract owner or the user him/her-self Parameters: Name Type Description userId String valid address Source: paratii.eth.users.js Returns: blockchain transaction Type Promise Example await paratii.eth.users.delete('some-id') &lt;async, static&gt; ParatiiEthUsers#get(userId) Get a users details from the blockchain Parameters: Name Type Description userId String valid address Source: paratii.eth.users.js Returns: information about the user Type Promise Example user = await paratii.eth.users.get('some-id') &lt;async, static&gt; ParatiiEthUsers#getRegistry() Get the contract instance of the user contract Source: paratii.eth.users.js Returns: Object representing the contract Type Promise &lt;async, static&gt; ParatiiEthUsers#update(userId, options) Updates a user details on the blockchain. Parameters: Name Type Description userId String valid address options Object information to update. Left-out data is kept the same. Source: paratii.eth.users.js Returns: updated data Type Promise Example await paratii.eth.users.update('some-id', {ipfsData: 'new-hash'}) × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.eth.vids.html":{"id":"paratii.eth.vids.html","title":"Class: vids","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: vids paratii.eth. vids new vids() The eth.vids namespace contains functions to interact with the video registration on the blockchain. Source: paratii.eth.vids.js Methods &lt;async, static&gt; ParatiiEthVids#create(options [, retry]) Record the video on the blockchain Parameters: Name Type Argument Default Description options Object data about the video retry Number &lt;optional&gt; 1 optional, default = 1 Source: paratii.eth.vids.js Returns: the video id Type Promise Example let videoId = await paratii.eth.vids.create({ id: 'some-id', price: 20, owner: 'some-address', ipfsHash: 'some-hash' }) &lt;async, static&gt; ParatiiEthVids#dislike(videoId) Writes a dislike for the video on the blockchain (contract Likes), and negates a like for the video, if it exists. Parameters: Name Type Description videoId String univocal video identifier Source: paratii.eth.vids.js Returns: transaction recording the dislike Type Promise Example let result = paratii.eth.vids.dislike('some-id') &lt;async, static&gt; ParatiiEthVids#doesDislike(videoId) Check if the current user has already disliked the video. Parameters: Name Type Description videoId String univocal video identifier Source: paratii.eth.vids.js Returns: true if the current user already disliked the video, false otherwise Type Promise Example let result = paratii.eth.vids.doesDislike('some-id') &lt;async, static&gt; ParatiiEthVids#doesLike(videoId) Check if the current user has already liked the video Parameters: Name Type Description videoId String univocal video identifier Source: paratii.eth.vids.js Returns: true if the current user already liked the video, false otherwise Type Promise Example let result = paratii.eth.vids.doesLike('some-id') &lt;async, static&gt; ParatiiEthVids#get(videoId) get data about the video Parameters: Name Type Description videoId String univocal video id Source: paratii.eth.vids.js Returns: data about the video Type Promise Example let video = eth.vids.get('0x12345') &lt;async, static&gt; ParatiiEthVids#getLikesContract() Get the contract instance of the likes contract Source: paratii.eth.vids.js Returns: Object representing the contract Type Promise Example let contract = await paratii.eth.vids.getLikesContract() &lt;async, static&gt; ParatiiEthVids#getVideoRegistry() Get the contract instance of the videos contract Source: paratii.eth.vids.js Returns: Object representing the contract Type Promise Example let contract = await paratii.eth.vids.getVideoRegistry() &lt;async, static&gt; ParatiiEthVids#getViewsContract() Get the contract instance of the views contract Source: paratii.eth.vids.js Returns: Object representing the contract Type Promise Example let contract = await paratii.eth.vids.getViewsContract() &lt;async, static&gt; ParatiiEthVids#like(videoId) Writes a like for the video on the blockchain (contract Likes), and negates a dislike for the video, if it exists. Parameters: Name Type Description videoId String univocal video identifier Source: paratii.eth.vids.js Returns: transaction recording the like Type Promise Example let result = paratii.eth.vids.like('some-id') &lt;static&gt; ParatiiEthVids#makeId() Creates a random id Source: paratii.eth.vids.js Returns: id created Type String Example let id = paratii.eth.vids.makeId() &lt;async, static&gt; ParatiiEthVids#sendLike(options) record a like/dislike to the video on the blockchain TODO RIVEDI I TIPI Parameters: Name Type Description options Object data about the video to like Properties Name Type Description videoId String univocal video id liked Boolean true/false Source: paratii.eth.vids.js Returns: transaction recording the like Type Promise Examples await paratii.eth.vids.sendLike({ videoId: 'some-id', liked: true }) await paratii.eth.vids.sendLike({ videoId: 'some-id', liked: false }) &lt;async, static&gt; ParatiiEthVids#update(videoId, options) Update the information on the video. Only the account that has registered the video, or the owner of the contract, can update the information. Parameters: Name Type Description videoId String univocal video identifier options Object key value pairs of properties and new values e.g. ({title: 'another-title'}) Source: paratii.eth.vids.js Returns: Updated video informations Type Promise Example paratii.eth.vids.update('some-video-id', {title: 'another-title'}) &lt;async, static&gt; ParatiiEthVids#userViewedVideo(options) Check if the viewer has already viewed the video Parameters: Name Type Description options Object data about the video and the viewer Properties Name Type Description viewer String viewer address videoId String univocal video identifier Source: paratii.eth.vids.js Returns: true if the current user already viewed the video, false otherwise Type Promise Example let result = await paratii.eth.vids.userViewedVideo({viewer:'some-user-id',videoId: 'some-video-id'}) &lt;async, static&gt; ParatiiEthVids#view(options) record a views to the video on the blockchain Parameters: Name Type Description options Object data about the video and the viewer Properties Name Type Description viewer String address of the viewer videoId String univocal video identifier ipfsData String ipfs multihash Source: paratii.eth.vids.js Returns: transaction recording the view Type Promise Example await paratii.eth.vids.view({viewer:'some-user-id',videoId: 'some-video-id'}) × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.eth.vouchers.html":{"id":"paratii.eth.vouchers.html","title":"Class: vouchers","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: vouchers paratii.eth. vouchers new vouchers() Functions for redeeming vouchers Source: paratii.eth.vouchers.js Methods &lt;async, static&gt; ParatiiEthVouchers#create(options) Function for creating a voucher. Can only be called by the owner of the contract. Parameters: Name Type Description options Object data about the voucher Properties Name Type Description voucherCode String unique string associated to this voucher amount Number amount of PTI in wei of this voucher Source: paratii.eth.vouchers.js Returns: the voucher id Type Promise Example await paratii.eth.vouchers.create({ voucherCode: 'some-id', amount: 10 }) &lt;async, static&gt; ParatiiEthVouchers#createVouchers(number, amount) Generates a given number of vouchers with unique IDs, and the given amount, and returns an array of objects. Parameters: Name Type Description number Number number of voucher to create amount Number amount of every voucher Source: paratii.eth.vouchers.js Returns: Object containing every voucher created Type Promise Example let vouchers = await paratii.eth.vouchers.createVouchers(10, 10) &lt;async, static&gt; ParatiiEthVouchers#getVouchersContract() Get the contract instance of the vouchers contract Source: paratii.eth.vouchers.js Returns: Object representing the contract Type Promise Example let contract = await paratii.eth.vids.getVouchersContract() &lt;async, static&gt; ParatiiEthVouchers#redeem(voucherCode) Function for redeeming a voucher to the current account's address. Parameters: Name Type Description voucherCode String univocal voucher code Source: paratii.eth.vouchers.js Returns: true if everything goes well, otherwise throws an error Type Promise Example await paratii.eth.vouchers.redeem('some-code') &lt;async, static&gt; ParatiiEthVouchers#test() throws a test error Source: paratii.eth.vouchers.js × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.eth.wallet.html":{"id":"paratii.eth.wallet.html","title":"Class: wallet","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: wallet paratii.eth. wallet new wallet(wallet, config) overrides some web3js wallet functionalties Parameters: Name Type Description wallet Object wallet to patch config Object configuration object to initialize Paratii object Source: paratii.eth.wallet.js Returns: patched wallet Type Object Methods &lt;static&gt; _decrypt(data, password) decrypts the wallet Parameters: Name Type Description data Object encrypted wallet password String password to decrypt Source: paratii.eth.wallet.js Returns: decrypted wallet Type Object Example let decryptedWallet = paratii.eth.wallet._decrypt(encryptedWallet,'some-psw') &lt;async, static&gt; create(numberOfAccounts, mnemonic) Create a wallet with a given number of accounts from a BIP39 mnemonic Parameters: Name Type Description numberOfAccounts Number number of accounts to be created mnemonic String optional - mnemonic of the wallet, if not specified a random one is generated Source: paratii.eth.wallet.js Returns: the created wallet Type Object Example wallet = await wallet.create(5, 'some long mnemonic phrase') &lt;static&gt; isValidMnemonic(mnemonic) check if the passed mnemonic is bip39 valid Parameters: Name Type Description mnemonic String mnemonic to check Source: paratii.eth.wallet.js Returns: true if the mnemonic is valid, false otherwise Type Boolean Example paratii.eth.wallet.isValidMnemonic('some long mnemonic phrase') &lt;static&gt; newMnemonic() generates a new mnemonic Source: paratii.eth.wallet.js Returns: newly generated mnemonic Type String Example let newMnemonic = paratii.eth.wallet.generateMnemonic() × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"paratii.ipfs.uploader.html":{"id":"paratii.ipfs.uploader.html","title":"Class: uploader","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: uploader uploader new uploader(opts) IPFS UPLOADER : Paratii IPFS uploader interface. Parameters: Name Type Description opts Object Source: paratii.ipfs.uploader.js Extends EventEmitter Methods &lt;static&gt; Uploader#_pinResponseHandler(ev) [_pinResponseHandler description] Parameters: Name Type Description ev Object [description] Source: paratii.ipfs.uploader.js Returns: [description] Type Object &lt;static&gt; Uploader#_signalTranscoder(files, ev) [_signalTranscoder description] TODO RIVEDI I TIPI Parameters: Name Type Description files Object [description] ev Object [description] Source: paratii.ipfs.uploader.js Returns: [description] Type Object &lt;static&gt; Uploader#_transcoderRespHander(ev) handles responses from the paratii-protocol in case of transcoding. Parameters: Name Type Description ev EventEmitter the transcoding job EventEmitter Source: paratii.ipfs.uploader.js Returns: returns various events based on transcoder response. Type function Example ? &lt;static&gt; Uploader#add(file) uploads a single file to *local* IPFS node Parameters: Name Type Description file File HTML5 File Object. Source: paratii.ipfs.uploader.js Returns: checkout the upload function below for details. Type EventEmitter Example let uploaderEv = paratiiIPFS.uploader.add(files) &lt;static&gt; Uploader#addAndTranscode(files) convenience method for adding and transcoding files Parameters: Name Type Description files Array Array of HTML5 File Objects Source: paratii.ipfs.uploader.js &lt;static&gt; Uploader#addDirectory(dirPath) upload an entire directory to IPFS Parameters: Name Type Description dirPath String path to directory Source: paratii.ipfs.uploader.js Returns: returns the {multihash, path, size} for the uploaded folder. Type Promise Example ? &lt;static&gt; Uploader#fsFileToPull(filePath) returns a generic file Object from a file path Parameters: Name Type Description filePath String Path to file. Source: paratii.ipfs.uploader.js Returns: generic file object. Type Object Example ? &lt;static&gt; Uploader#getMetaData(fileHash, options) [getMetaData description] Parameters: Name Type Description fileHash Object [description] options Object [description] Source: paratii.ipfs.uploader.js Returns: [description] Type Object &lt;static&gt; Uploader#html5FileToPull(file) returns a generic File Object with a Pull Stream from an HTML5 File Parameters: Name Type Description file File HTML5 File Object Source: paratii.ipfs.uploader.js Returns: generic file object. Type Object Example ? &lt;static&gt; Uploader#onDrop(ev) ???? Parameters: Name Type Description ev ? ? Source: paratii.ipfs.uploader.js Returns: ? Type ? &lt;static&gt; Uploader#pinFile(fileHash, options) [pinFile description] Parameters: Name Type Description fileHash Object [description] options Object [description] Source: paratii.ipfs.uploader.js Returns: [description] Type Object &lt;static&gt; Uploader#transcode(fileHash, options) signals transcoder(s) to transcode fileHash Parameters: Name Type Description fileHash String IPFS file hash. options Object ref: https://github.com/Paratii-Video/paratii-lib/blob/master/docs/paratii-ipfs.md#ipfsuploadertranscodefilehash-options Source: paratii.ipfs.uploader.js Returns: returns EventEmitter with the following events: - 'uploader:progress': (hash, chunkSize, percent) client to transcoder upload progress. - 'transcoding:started': (hash, author) - 'transcoding:progress': (hash, size, percent) - 'transcoding:downsample:ready' (hash, size) - 'transcoding:done': (hash, transcoderResult) triggered when the transcoder is done - returns the hash of the transcoded file - 'transcoder:error': (err) triggered whenever an error occurs. Type EventEmitter Example ? &lt;static&gt; Uploader#upload(files) upload an Array of files as is to the local IPFS node Parameters: Name Type Description files Array HTML5 File Object Array. Source: paratii.ipfs.uploader.js Returns: returns EventEmitter with the following events: - 'start': uploader started. - 'progress': (chunkLength, progressPercent) - 'fileReady': (file) triggered when a file is uploaded locally. - 'done': (files) triggered when the uploader is done locally. - 'error': (err) triggered whenever an error occurs. Type EventEmitter Example ? &lt;static&gt; Uploader#xhrUpload(file, hashedFile, ev) Upload a file over XHR to the transcoder. To be called with an event emitter as the last argument Parameters: Name Type Description file Object file to upload hashedFile String hash of the file ?? ev EventEmitter event emitter Source: paratii.ipfs.uploader.js Example this.xhrUpload(file, hashedFile, ev) × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "},"ParatiiIPFS.html":{"id":"ParatiiIPFS.html","title":"Class: ParatiiIPFS","body":" Paratii Classes paratiiparatii.coreparatii.core.usersparatii.core.vidsparatii.dbparatii.db.usersparatii.db.vidsparatii.ethparatii.eth.eventsparatii.eth.tcrparatii.eth.usersparatii.eth.vidsparatii.eth.vouchersparatii.eth.walletparatii.ipfs.uploaderParatiiIPFS Global Global Class: ParatiiIPFS ParatiiIPFS Contains functions to interact with the IPFS instance. new ParatiiIPFS(config) Parameters: Name Type Description config Object configuration object to initialize Paratii object Source: paratii.ipfs.js Methods &lt;async&gt; add(fileStream) Adds the file to ipfs Parameters: Name Type Description fileStream ReadStream ReadStream of the file. Can be created with fs.createReadStream(path) Source: paratii.ipfs.js Returns: data about the added file (path,multihash,size) Type Promise Example let path = 'test/data/some-file.txt' let fileStream = fs.createReadStream(path) let result = await paratiiIPFS.add(fileStream) &lt;async&gt; addAndPinJSON(data) convenient method to add JSON and send it for persistance storage. Parameters: Name Type Description data object JSON object to store Source: paratii.ipfs.js Returns: returns multihash of the stored object. Type string Example let result = await paratiiIPFS.addAndPinJSON(data) &lt;async&gt; addJSON(data) adds a data Object to the IPFS local instance Parameters: Name Type Description data Object JSON object to store Source: paratii.ipfs.js Returns: promise with the ipfs multihash Type Promise Example let result = await paratiiIPFS.addJSON(data) error(msg) log errors on the console if verbose is set Parameters: Name Type Argument Description msg String &lt;repeatable&gt; error message Source: paratii.ipfs.js Example paratii.ipfs.error(&quot;some-text&quot;) &lt;async&gt; get(hash) get file from ipfs Parameters: Name Type Description hash String multihash of the file Source: paratii.ipfs.js Returns: the file (path,content) Type Promise Example let result = await paratiiIPFS.add(fileStream) let hash = result[0].hash let fileContent = await paratiiIPFS.get(hash) getIPFSInstance() get an ipfs instance of jsipfs. Singleton pattern Source: paratii.ipfs.js Returns: Ipfs instance Type Object Example ipfs = await paratii.ipfs.getIPFSInstance() &lt;async&gt; getJSON(multihash) gets a JSON object stored in IPFS Parameters: Name Type Description multihash String ipfs multihash of the object Source: paratii.ipfs.js Returns: requested Object Type Promise Example let jsonObj = await paratiiIPFS.getJSON('some-multihash') log(msg) log messages on the console if verbose is set Parameters: Name Type Argument Description msg String &lt;repeatable&gt; text to log Source: paratii.ipfs.js Example paratii.ipfs.log(&quot;some-text&quot;) start(callback) Starts the IPFS node Parameters: Name Type Description callback function callback function Source: paratii.ipfs.js Returns: DON'T KNOW? Type ? Example ? stop(callback) Stops the IPFS node. Parameters: Name Type Description callback function callback function Source: paratii.ipfs.js Returns: DON'T KNOW? Type ? Example ? warn(msg) log warns on the console if verbose is set Parameters: Name Type Argument Description msg String &lt;repeatable&gt; warn text Source: paratii.ipfs.js Example paratii.ipfs.warn(&quot;some-text&quot;) × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-04-06T14:07:57+02:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
